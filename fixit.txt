FLOWCHART TOOL - FIXIT DOCUMENTATION
=====================================

PURPOSE OF THIS DOCUMENT:
=========================
This document serves as a detailed troubleshooting guide for the Flowchart Creation Tool. Each entry documents a specific issue that was encountered, the root cause analysis, and the solution that was implemented. The documentation is written in a way that is so detailed and clear that if an AI agent encounters a similar problem in the future, they can reference this document and understand how to fix it.

The entries in this document follow a structured format:
- Problem Description: What was broken and what behavior was observed
- Root Cause: Why the problem occurred (technical analysis)
- Solution: How the problem was fixed (code changes and reasoning)
- Key Learnings: Important insights that can prevent similar issues
- Future Reference: How to handle similar problems

When encountering a new issue that seems similar to one documented here, search this document for keywords related to the problem. The detailed explanations should provide enough context to understand and fix the issue without needing to ask the user for clarification.

=====================================

INCIDENT: Dropdown Layout Inconsistency in Properties Popup
DATE: [Current Date]
ISSUE ID: DROPDOWN_LAYOUT_001

PROBLEM DESCRIPTION:
===================
The Section Name dropdown in the Node Properties popup was not displaying with the same layout as other dropdowns (specifically the Node Type dropdown). The Section Name dropdown was appearing above its label instead of to the right of it, creating visual inconsistency.

WHAT WE WERE ATTEMPTING TO DO:
=============================
- Make the Section Name dropdown use the same horizontal layout as the Node Type dropdown
- Ensure consistent visual appearance across all dropdown fields in the properties popup
- Have the label appear on the left and the dropdown on the right, side by side

ISSUES ENCOUNTERED:
==================
1. INITIAL ATTEMPT - Vertical Layout:
   - Changed the Section Name dropdown to use `flex-direction: column`
   - This put the label above the dropdown, but user wanted horizontal layout like Node Type

2. SECOND ATTEMPT - CSS Override:
   - Tried to override the fieldDiv styling for dropdowns
   - Still resulted in vertical layout instead of horizontal

3. ROOT CAUSE DISCOVERY:
   - The Node Type dropdown uses `isQuestionTypeDropdown: true` which gets special handling
   - The Section Name dropdown was using `isDropdown: true` which goes through different code path
   - The `isDropdown` code path was designed for vertical layout, not horizontal

TECHNICAL DETAILS:
==================
- File: graph.js
- Node Type dropdown: Uses `isQuestionTypeDropdown: true` → special handling around line 910
- Section Name dropdown: Was using `isDropdown: true` → different handling around line 1005
- The `isDropdown` path was creating vertical layout with `flex-direction: column`
- The `isQuestionTypeDropdown` path uses standard horizontal layout

SOLUTION THAT WORKED:
====================
1. Changed Section Name field property from `isDropdown: true` to `isSectionNameDropdown: true`
2. Added new special handling for `isSectionNameDropdown` that mirrors the `isQuestionTypeDropdown` handling
3. Used the exact same layout code: `fieldDiv.appendChild(label)` then `fieldDiv.appendChild(dropdown)`
4. Applied the same CSS styling as the Node Type dropdown

CODE CHANGES:
=============
1. In properties array definition (around line 760):
   - Changed: `isDropdown: true`
   - To: `isSectionNameDropdown: true`

2. Added new handling section (around line 986):
   ```javascript
   // Special handling for section name dropdown
   if (prop.isSectionNameDropdown) {
     const dropdown = document.createElement('select');
     dropdown.id = prop.id;
     dropdown.style.cssText = `
       flex: 1;
       padding: 8px 12px;
       border: 1px solid #ddd;
       border-radius: 6px;
       background: white;
       color: #333;
       font-size: 14px;
       cursor: pointer;
       transition: all 0.2s ease;
     `;
     
     // Add options, set value, add change listener...
     
     fieldDiv.appendChild(label);
     fieldDiv.appendChild(dropdown);
     content.appendChild(fieldDiv);
     return; // Skip the normal field creation
   }
   ```

KEY LEARNINGS:
==============
1. When trying to make UI elements look the same, check if they're using different code paths
2. Look for existing working examples (Node Type dropdown) and replicate their approach
3. Don't try to override CSS when the issue is in the JavaScript logic
4. Create new property types (`isSectionNameDropdown`) rather than trying to modify existing ones
5. Always use the same layout pattern: `fieldDiv.appendChild(label)` then `fieldDiv.appendChild(dropdown)`

PREVENTION:
===========
- When adding new dropdown fields, use the same pattern as existing working dropdowns
- If a dropdown needs horizontal layout, use `isQuestionTypeDropdown` or create a similar property
- If a dropdown needs vertical layout, use `isDropdown`
- Always test new dropdowns against existing ones to ensure visual consistency

RELATED FILES:
=============
- graph.js (main file with properties popup logic)
- style.css (general styling, but not the issue in this case)

FUTURE REFERENCE:
================
If you encounter similar dropdown layout issues:
1. Check what property type the working dropdown uses (`isQuestionTypeDropdown`)
2. Check what property type the broken dropdown uses (`isDropdown`)
3. Either change the property type or create a new one that mirrors the working approach
4. Use the same layout code pattern: label first, then dropdown, both appended to fieldDiv

=====================================

INCIDENT: Context Menu Node Creation Issues
DATE: [Current Date]
ISSUE ID: CONTEXT_MENU_CREATION_001

PROBLEM DESCRIPTION:
===================
1. Question nodes created via right-click context menu were not showing the "Choose Question Type" dropdown
2. Calculation nodes created via right-click context menu were throwing "graph.getModel is not a function" error
3. Context menu node creation was inconsistent with drag-and-drop node creation

WHAT WE WERE ATTEMPTING TO DO:
=============================
- Make right-click context menu create nodes with the same functionality as drag-and-drop
- Ensure question nodes from context menu show the dropdown for selecting question type
- Fix JavaScript errors when creating calculation nodes from context menu

ISSUES ENCOUNTERED:
==================
1. GRAPH REFERENCE ERROR:
   - Context menu function `placeNodeAtClickLocation(graph, nodeType)` was trying to use `graph.getModel()`
   - The `graph` parameter wasn't properly available, causing "graph.getModel is not a function" error

2. INCONSISTENT NODE CREATION:
   - Drag-and-drop created nodes with label "question node" which triggered dropdown in `refreshAllCells()`
   - Context menu created nodes with empty label, so `refreshAllCells()` didn't detect them as needing dropdown
   - Different initialization logic between drag-and-drop and context menu

3. MISSING CALCULATION NODE SUPPORT:
   - Context menu was missing the calculation node handler
   - `placeCalcNode` element wasn't properly referenced in context menu setup

TECHNICAL DETAILS:
==================
- File: context-menus.js
- Drag-and-drop logic: Uses `mxUtils.makeDraggable` with callback that gets `graph` parameter
- Context menu logic: Was trying to use `graph` parameter that wasn't always available
- `refreshAllCells()` function checks for placeholder text "question node" to show dropdown
- Context menu was creating nodes with empty labels instead of "question node"

SOLUTION THAT WORKED:
====================
1. FIXED GRAPH REFERENCE ERROR:
   ```javascript
   // Use the global graph variable if the parameter is not available
   const graphToUse = graph || window.graph;
   if (!graphToUse) {
     console.error('Graph not available for node placement');
     return;
   }
   ```

2. LINKED CONTEXT MENU TO DRAG-AND-DROP LOGIC:
   - Made context menu use same style as drag-and-drop elements
   - Made context menu use same initialization logic as drag-and-drop
   - Made context menu use same finalization logic as drag-and-drop

3. ADDED MISSING CALCULATION NODE SUPPORT:
   - Added `placeCalcNode` variable declaration
   - Added `placeCalcNode` element initialization
   - Added calculation node event handler

CODE CHANGES:
=============
1. Fixed graph reference in `placeNodeAtClickLocation` function:
   ```javascript
   const graphToUse = graph || window.graph;
   // Use graphToUse instead of graph throughout the function
   ```

2. Made context menu use same style as drag-and-drop:
   ```javascript
   if (nodeType === 'question') {
     // Use the same style as the drag-and-drop elements
     const toolbarShape = document.querySelector('.shape[data-type="question"]');
     if (toolbarShape) {
       style = toolbarShape.dataset.style;
       if (!style.includes("pointerEvents=")) {
         style += "pointerEvents=1;overflow=fill;";
       }
     }
     label = "question node"; // Set placeholder label to trigger dropdown
   }
   ```

3. Added same initialization logic as drag-and-drop:
   ```javascript
   if (nodeType === 'question') {
     if (typeof window.isQuestion === 'function' && window.isQuestion(cell)) {
       if (typeof window.getQuestionType === 'function') {
         const qType = window.getQuestionType(cell);
         if (qType && typeof window.setQuestionType === 'function') {
           window.setQuestionType(cell, qType);
         }
       }
     }
   }
   ```

4. Added calculation node support:
   ```javascript
   // Variable declaration
   let placeCalcNode, placeNotesNode, placeChecklistNode, ...
   
   // Element initialization
   placeCalcNode = document.getElementById('placeCalcNode');
   
   // Event handler
   if (placeCalcNode) {
     placeCalcNode.addEventListener('click', function() {
       placeNodeAtClickLocation(graph, 'calculation');
       hideContextMenu();
     });
   }
   ```

KEY LEARNINGS:
==============
1. When context menu and drag-and-drop behave differently, check if they're using different code paths
2. Always use the global `window.graph` as fallback when graph parameter might not be available
3. Make context menu use the exact same logic as drag-and-drop for consistency
4. Check for missing element references and event handlers when adding new functionality
5. Use placeholder text that `refreshAllCells()` can detect to trigger proper initialization

PREVENTION:
===========
- Always link context menu functionality to the same functions as drag-and-drop
- Use fallback graph reference to prevent "graph.getModel is not a function" errors
- Ensure all node types have proper event handlers in context menu setup
- Test context menu creation against drag-and-drop creation to ensure consistency

RELATED FILES:
=============
- context-menus.js (main file with context menu logic)
- events.js (drag-and-drop logic to replicate)
- script.js (refreshAllCells function that handles dropdown display)

FUTURE REFERENCE:
================
If you encounter similar context menu issues:
1. Check if context menu is using the same logic as drag-and-drop
2. Use `const graphToUse = graph || window.graph;` to prevent graph reference errors
3. Make context menu read styles from drag-and-drop elements for consistency
4. Ensure all node types have proper event handlers in context menu setup
5. Use placeholder text that triggers proper initialization in `refreshAllCells()`

=====================================

INCIDENT: Calculation Node Properties Menu Migration
DATE: [Current Date]
ISSUE ID: CALC_PROPERTIES_MIGRATION_001

PROBLEM DESCRIPTION:
===================
The calculation node had complex inline editing functionality that was difficult to maintain and use. The node displayed multiple dropdowns, input fields, and conditional content directly on the canvas, making it cluttered and hard to configure. Users needed a cleaner, more organized way to configure calculation node properties.

WHAT WE WERE ATTEMPTING TO DO:
=============================
- Move all calculation node configuration from inline canvas editing to a dedicated properties popup
- Create a comprehensive properties menu that appears when double-clicking a calculation node
- Simplify the on-canvas display to show only essential information
- Make the configuration process more user-friendly and organized

ISSUES ENCOUNTERED:
==================
1. COMPLEX INLINE UI:
   - Calculation nodes had multiple dropdowns, input fields, and conditional content on the canvas
   - The UI was cluttered and difficult to use
   - Conditional display logic was complex and hard to maintain

2. DOUBLE-CLICK HANDLER CONFLICTS:
   - Multiple double-click handlers were conflicting with each other
   - One handler was calling the wrong function name (`showCalculationProperties` instead of `showCalculationNodeProperties`)
   - The correct handler was being overridden by an incorrect one

3. PROPERTIES POPUP COMPLEXITY:
   - Needed to create a comprehensive popup with multiple field types
   - Had to handle dynamic content (calculation terms, conditional fields)
   - Required proper event handling for all field types

TECHNICAL DETAILS:
==================
- File: calc.js (main calculation node logic)
- File: events.js (double-click handlers)
- File: graph.js (conflicting double-click handler)
- The inline UI was generated in `updateCalculationNodeCell()` function
- Properties popup was created in `showCalculationNodeProperties()` function

SOLUTION THAT WORKED:
====================
1. SIMPLIFIED ON-CANVAS DISPLAY:
   ```javascript
   // Replaced complex inline form with simple display
   const html = `
     <div style="padding: 20px; font-family: Arial, sans-serif;">
       <div style="font-weight: bold; color: #2196F3; margin-bottom: 10px;">${cell._calcTitle}</div>
       <div style="margin-bottom: 8px;"><strong>Calculation:</strong> ${displayCalculation}</div>
       <div style="margin-bottom: 8px;"><strong>Condition:</strong> ${displayCondition}</div>
       <div style="margin-bottom: 8px;"><strong>Output:</strong> ${displayOutput}</div>
       <div style="font-style: italic; color: #666; font-size: 12px; margin-top: 15px;">Double-click to configure</div>
     </div>
   `;
   ```

2. CREATED COMPREHENSIVE PROPERTIES POPUP:
   ```javascript
   window.showCalculationNodeProperties = function(cell) {
     // Create modal popup with all configuration options
     const modal = document.createElement('div');
     modal.className = 'calc-properties-modal';
     
     // Add all necessary fields:
     // - Title input
     // - Calculation terms (dynamic)
     // - Comparison operator dropdown
     // - Threshold number input
     // - Final output type dropdown
     // - Conditional fields (text input or checkbox)
   };
   ```

3. FIXED DOUBLE-CLICK HANDLER CONFLICTS:
   ```javascript
   // In events.js - corrected function name
   if (typeof window.isCalculationNode === 'function' && window.isCalculationNode(cell)) {
     if (typeof window.showCalculationNodeProperties === 'function') {
       window.showCalculationNodeProperties(cell); // Fixed function name
     }
     mxEvent.consume(evt);
     return;
   }
   
   // In graph.js - removed conflicting handler
   // Removed the duplicate double-click handler that was calling wrong function
   ```

4. ADDED HELPER FUNCTIONS FOR POPUP:
   ```javascript
   // Helper functions for creating different field types
   function createField(label, input) { ... }
   function createDropdownField(label, options, value, onChange) { ... }
   function createCheckboxField(label, checked, onChange) { ... }
   function createCalculationTermsContainer(cell) { ... }
   function createCalculationTermField(term, index, cell) { ... }
   ```

CODE CHANGES:
=============
1. Simplified `updateCalculationNodeCell()` function:
   - Removed complex inline form HTML
   - Added simple display with essential information
   - Added "Double-click to configure" instruction

2. Created `showCalculationNodeProperties()` function:
   - Comprehensive modal popup with all configuration options
   - Dynamic calculation terms management
   - Conditional field display based on output type
   - Proper event handling for all field types

3. Fixed double-click handlers:
   - Corrected function name in events.js
   - Removed conflicting handler in graph.js

4. Added helper functions:
   - `createField()` - basic field creation
   - `createDropdownField()` - dropdown field creation
   - `createCheckboxField()` - checkbox field creation
   - `createCalculationTermsContainer()` - dynamic terms management
   - `createCalculationTermField()` - individual term field creation

KEY LEARNINGS:
==============
1. Complex inline UI should be moved to dedicated properties popups for better UX
2. Always check for conflicting event handlers when implementing new functionality
3. Use helper functions to reduce code duplication in complex UI creation
4. Provide clear visual cues (like "Double-click to configure") for user interaction
5. Simplify on-canvas display to show only essential information

PREVENTION:
===========
- When nodes have complex configuration, consider moving to properties popup
- Always check for existing event handlers before adding new ones
- Use consistent function naming to avoid conflicts
- Create helper functions for repeated UI patterns
- Test double-click functionality thoroughly when adding new node types

RELATED FILES:
=============
- calc.js (main calculation node logic and properties popup)
- events.js (double-click handlers)
- graph.js (removed conflicting handler)

FUTURE REFERENCE:
================
To replicate this process for other nodes:
1. Identify complex inline UI that should be moved to properties popup
2. Create comprehensive properties popup with all configuration options
3. Simplify on-canvas display to show only essential information
4. Add "Double-click to configure" instruction
5. Check for and resolve any conflicting event handlers
6. Create helper functions for repeated UI patterns
7. Test thoroughly to ensure all functionality works correctly

MIGRATION PROCESS FOR OTHER NODES:
==================================
1. **ANALYZE CURRENT UI**: Identify what configuration options are currently inline
2. **DESIGN POPUP STRUCTURE**: Plan the layout and organization of the properties popup
3. **CREATE POPUP FUNCTION**: Build the comprehensive properties popup
4. **SIMPLIFY CANVAS DISPLAY**: Replace complex inline UI with simple display
5. **ADD HELPER FUNCTIONS**: Create reusable functions for common UI patterns
6. **FIX EVENT HANDLERS**: Ensure double-click handlers work correctly
7. **TEST THOROUGHLY**: Verify all functionality works in the new popup
8. **ADD USER INSTRUCTIONS**: Include clear instructions for accessing configuration

=====================================

INCIDENT: Right-Click Menu Node Creation Issues for Special Node Types
DATE: [Current Date]
ISSUE ID: RIGHT_CLICK_SPECIAL_NODES_001

PROBLEM DESCRIPTION:
===================
1. Linked Logic nodes created via right-click context menu appeared as ugly, empty rectangles
2. Hidden Checkbox and Hidden Textbox nodes created via right-click context menu also appeared as basic rectangles
3. Double-clicking on these nodes created via right-click menu did nothing (no properties menu opened)
4. Right-click menu node creation was inconsistent with drag-and-drop node creation for special node types

WHAT WE WERE ATTEMPTING TO DO:
=============================
- Make right-click context menu create special node types (Linked Logic, Hidden Checkbox, Hidden Textbox) with the same appearance and functionality as drag-and-drop
- Ensure these nodes have proper styling, dimensions, and initialization
- Make double-click functionality work correctly on nodes created via right-click menu

ISSUES ENCOUNTERED:
==================
1. MISSING NODE TYPE CASES:
   - The `placeNodeAtClickLocation` function in context-menus.js was missing cases for `hiddenCheckbox`, `hiddenTextbox`, and `linkedLogic` node types
   - These node types were falling through to the default case, creating basic cells without proper styling

2. MISSING INITIALIZATION LOGIC:
   - Even when basic cells were created, they lacked the proper initialization logic
   - No default properties were being set (like `_hiddenNodeId`, `_linkedLogicNodeId`, etc.)
   - No update functions were being called to set up the proper display

3. INCONSISTENT STYLING:
   - Right-click created nodes had different styling than drag-and-drop created nodes
   - Missing proper colors, dimensions, and visual properties

TECHNICAL DETAILS:
==================
- File: context-menus.js
- Function: `placeNodeAtClickLocation(graph, nodeType)`
- The function had cases for standard node types but was missing special node types
- Drag-and-drop uses `createNode()` function in nodes.js which has proper initialization
- Right-click menu was creating basic `insertVertex()` calls without proper setup

SOLUTION THAT WORKED:
====================
1. ADDED MISSING NODE TYPE CASES:
   ```javascript
   } else if (nodeType === 'hiddenCheckbox') {
     style = "shape=roundRect;rounded=1;arcSize=20;whiteSpace=wrap;html=1;nodeType=hiddenCheckbox;section=1;strokeWidth=3;strokeColor=#0066CC;strokeDasharray=5,5;";
     label = "Hidden Checkbox";
     width = 150;
     height = 80;
   } else if (nodeType === 'hiddenTextbox') {
     style = "shape=roundRect;rounded=1;arcSize=20;whiteSpace=wrap;html=1;nodeType=hiddenTextbox;section=1;strokeWidth=3;strokeColor=#0066CC;strokeDasharray=5,5;";
     label = "Hidden Textbox";
     width = 150;
     height = 80;
   } else if (nodeType === 'linkedLogic') {
     style = "shape=roundRect;rounded=1;arcSize=20;whiteSpace=wrap;html=1;nodeType=linkedLogic;section=1;fillColor=#DDA0DD;strokeColor=#9370DB;";
     label = "Linked Logic";
     width = 150;
     height = 80;
   }
   ```

2. ADDED PROPER INITIALIZATION LOGIC:
   ```javascript
   } else if (nodeType === 'hiddenCheckbox') {
     cell._hiddenNodeId = "hidden_checkbox";
     if (typeof window.updateHiddenCheckboxNodeCell === 'function') {
       window.updateHiddenCheckboxNodeCell(cell);
     }
   } else if (nodeType === 'hiddenTextbox') {
     cell._hiddenNodeId = "hidden_textbox";
     cell._defaultText = "";
     if (typeof window.updateHiddenTextboxNodeCell === 'function') {
       window.updateHiddenTextboxNodeCell(cell);
     }
   } else if (nodeType === 'linkedLogic') {
     cell._linkedLogicNodeId = "linked_logic";
     cell._linkedFields = [];
     if (typeof window.updateLinkedLogicNodeCell === 'function') {
       window.updateLinkedLogicNodeCell(cell);
     }
   }
   ```

CODE CHANGES:
=============
1. Added missing node type cases in `placeNodeAtClickLocation` function:
   - Added `hiddenCheckbox` case with proper styling and dimensions
   - Added `hiddenTextbox` case with proper styling and dimensions
   - Added `linkedLogic` case with proper styling and dimensions

2. Added proper initialization logic for each node type:
   - Hidden Checkbox: Sets `_hiddenNodeId` and calls `updateHiddenCheckboxNodeCell`
   - Hidden Textbox: Sets `_hiddenNodeId`, `_defaultText` and calls `updateHiddenTextboxNodeCell`
   - Linked Logic: Sets `_linkedLogicNodeId`, `_linkedFields` and calls `updateLinkedLogicNodeCell`

3. Applied consistent styling:
   - Hidden nodes: Blue dashed border (`strokeColor=#0066CC;strokeDasharray=5,5`)
   - Linked Logic: Light purple fill (`fillColor=#DDA0DD;strokeColor=#9370DB`)
   - All nodes: Proper dimensions (150x80)

KEY LEARNINGS:
==============
1. When adding new node types, ensure both drag-and-drop AND right-click menu support them
2. Right-click menu node creation must mirror drag-and-drop node creation exactly
3. Always include proper initialization logic for special node types
4. Check that all node types have proper styling, dimensions, and default properties
5. Test both creation methods to ensure consistency

PREVENTION:
===========
- When adding new node types, update both `createNode()` in nodes.js AND `placeNodeAtClickLocation()` in context-menus.js
- Always include proper initialization logic for special node types
- Use the same styling, dimensions, and properties for both creation methods
- Test right-click menu creation against drag-and-drop creation for all node types

RELATED FILES:
=============
- context-menus.js (main file with right-click menu logic)
- nodes.js (drag-and-drop node creation logic to replicate)
- graph.js (double-click handlers for properties menus)

FUTURE REFERENCE:
================
When adding new special node types:
1. Add the node type case to `placeNodeAtClickLocation()` function
2. Include proper styling, dimensions, and label
3. Add initialization logic with default properties
4. Call the appropriate update function
5. Test both drag-and-drop and right-click menu creation
6. Ensure double-click functionality works correctly

PATTERN FOR NEW NODE TYPES:
===========================
```javascript
// 1. Add styling case
} else if (nodeType === 'newNodeType') {
  style = "proper;styling;string;";
  label = "Node Label";
  width = 150;
  height = 80;
}

// 2. Add initialization case
} else if (nodeType === 'newNodeType') {
  cell._newNodeProperty = "default_value";
  if (typeof window.updateNewNodeTypeCell === 'function') {
    window.updateNewNodeTypeCell(cell);
  }
}
```

=====================================

INCIDENT: PDF ID Generation Using Wrong Property Field
DATE: [Current Date]
ISSUE ID: PDF_ID_GENERATION_001

PROBLEM DESCRIPTION:
===================
Copy ID buttons for form fields and location IDs were generating incorrect IDs that used the PDF Name field ("Test") instead of the PDF File field ("example.pdf"). This resulted in IDs like "test_q1_name_1" instead of the expected "example_q1_name_1".

WHAT WE WERE ATTEMPTING TO DO:
=============================
- Make Copy ID buttons use the PDF File field value (e.g., "example.pdf") instead of PDF Name field value (e.g., "Test")
- Ensure location ID generation also uses the PDF File field
- Sanitize the PDF filename by removing the .pdf extension before using it in IDs

ISSUES ENCOUNTERED:
==================
1. PROPERTY FIELD MISMATCH:
   - The PDF Node Properties dialog stores the filename in `_pdfFile` property
   - The ID generation functions were looking for `_pdfFilename` property (which doesn't exist)
   - This caused a fallback to `_pdfName` property ("Test") instead of using `_pdfFile` ("example.pdf")

2. INCONSISTENT PROPERTY NAMES:
   - Dialog field "PDF File" maps to `_pdfFile` property
   - ID generation was looking for `_pdfFilename` property
   - No `_pdfFilename` property was being set anywhere in the code

3. MULTIPLE FUNCTIONS AFFECTED:
   - `copyMultipleTextboxId` function in script.js
   - `copyMultipleDropdownId` function in questions.js
   - `showLocationIdsPopup` function in script.js
   - `showDropdownLocationIdsPopup` function in script.js

TECHNICAL DETAILS:
==================
- Files: script.js, questions.js
- Function: `findPdfNameForQuestion()` in both files
- The function was checking: `startCell._pdfFilename || startCell._pdfUrl || startCell._pdfName`
- But the actual property being set was: `startCell._pdfFile`
- This caused the function to skip `_pdfFilename` (doesn't exist) and `_pdfUrl` (empty) and use `_pdfName` ("Test")

SOLUTION THAT WORKED:
====================
1. FIXED PROPERTY FIELD NAMES:
   ```javascript
   // Before (incorrect):
   if (startCell._pdfName || startCell._pdfFilename || startCell._pdfUrl) {
     return {
       filename: startCell._pdfFilename || startCell._pdfUrl || startCell._pdfName || "",
       // ...
     };
   }
   
   // After (correct):
   if (startCell._pdfName || startCell._pdfFile || startCell._pdfUrl) {
     return {
       filename: startCell._pdfFile || startCell._pdfUrl || startCell._pdfName || "",
       // ...
     };
   }
   ```

2. UPDATED ALL OCCURRENCES:
   - Fixed `findPdfNameForQuestion()` function in script.js (2 locations)
   - Fixed `findPdfNameForQuestion()` function in questions.js (2 locations)
   - Updated location ID generation functions to use PDF filename

3. MAINTAINED PROPER PRIORITY:
   - `_pdfFile` (PDF File field) - highest priority
   - `_pdfUrl` (PDF URL field) - second priority  
   - `_pdfName` (PDF Name field) - fallback

CODE CHANGES:
=============
1. In script.js `findPdfNameForQuestion()` function:
   - Changed `startCell._pdfFilename` to `startCell._pdfFile` (2 locations)
   - Updated property checks and filename assignment

2. In questions.js `findPdfNameForQuestion()` function:
   - Changed `startCell._pdfFilename` to `startCell._pdfFile` (2 locations)
   - Updated property checks and filename assignment

3. In location ID generation functions:
   - Added PDF filename detection using updated `findPdfNameForQuestion()`
   - Added PDF filename sanitization using `sanitizePdfName()`
   - Updated prefix generation to include PDF filename

KEY LEARNINGS:
==============
1. Always verify that property names match between dialog fields and ID generation functions
2. Check the actual property names being set in the dialog, not assumed names
3. When multiple functions use the same logic, update all of them consistently
4. Test with actual data to ensure the correct property is being used
5. Property field names in dialogs may not match the internal property names

PREVENTION:
===========
- When adding new dialog fields, verify the property name mapping
- Check that ID generation functions use the correct property names
- Test Copy ID functionality with actual data to ensure correct values are used
- Document property name mappings between dialogs and internal functions
- Use consistent property naming conventions across the codebase

RELATED FILES:
=============
- script.js (main ID generation functions)
- questions.js (dropdown ID generation functions)
- PDF Node Properties dialog (sets _pdfFile property)

FUTURE REFERENCE:
================
When working with PDF properties and ID generation:
1. Verify the actual property name being set in the dialog
2. Check that ID generation functions use the same property name
3. Test with actual data to ensure correct values are being used
4. Update all related functions consistently
5. Maintain proper priority order: _pdfFile > _pdfUrl > _pdfName

PROPERTY MAPPING REFERENCE:
===========================
- PDF Name field → `_pdfName` property
- PDF File field → `_pdfFile` property  
- PDF Price field → `_pdfPrice` property
- PDF URL field → `_pdfUrl` property (if exists)

ID GENERATION PRIORITY:
======================
1. `_pdfFile` (PDF File field) - preferred for filenames
2. `_pdfUrl` (PDF URL field) - fallback for URLs
3. `_pdfName` (PDF Name field) - final fallback for display names

=====================================

INCIDENT: Draggable Popup Teleporting Issue
DATE: [Current Date]
ISSUE ID: DRAGGABLE_POPUP_TELEPORT_001

PROBLEM DESCRIPTION:
===================
When trying to drag a popup (specifically the Location IDs popup), the popup would "teleport" or jump to an unexpected position when the user started dragging. The popup would move to a location that was offset from where the user's mouse cursor was, making dragging feel broken and unpredictable.

WHAT WE WERE ATTEMPTING TO DO:
=============================
- Make the Location IDs popup draggable by clicking and dragging the header
- Ensure smooth, predictable dragging behavior that follows the mouse cursor
- Allow users to move the popup to any position on screen

ISSUES ENCOUNTERED:
==================
1. TRANSFORM CONFLICTS:
   - The popup was initially centered using `transform: translate(-50%, -50%)`
   - When dragging started, we were applying a new transform that conflicted with the original centering
   - This caused the popup to "teleport" to an unexpected position

2. POSITIONING CALCULATION ERRORS:
   - The drag logic was trying to calculate positions relative to the original centered position
   - But the mouse position was relative to the current screen position
   - This mismatch caused the teleporting behavior

3. INCONSISTENT POSITIONING METHODS:
   - Initial positioning used `transform: translate(-50%, -50%)`
   - Dragging used `transform: translate(x, y)` 
   - These two transform methods conflicted with each other

TECHNICAL DETAILS:
==================
- File: script.js
- Function: `makePopupDraggable(popup)`
- The popup was initially positioned with CSS: `top: 50%; left: 50%; transform: translate(-50%, -50%)`
- When dragging started, we were applying: `popup.style.transform = 'translate(${currentX}px, ${currentY}px)'`
- This created a conflict between the centering transform and the dragging transform

SOLUTION THAT WORKED:
====================
1. CLEAN TRANSITION FROM CENTERING TO DRAGGING:
   ```javascript
   function dragStart(e) {
     // Get the current actual position of the popup
     const rect = popup.getBoundingClientRect();
     initialX = rect.left;
     initialY = rect.top;
     
     // Get the mouse position relative to the popup
     startX = e.clientX - initialX;
     startY = e.clientY - initialY;
     
     // Remove the centering transform and set absolute positioning
     popup.style.top = initialY + 'px';
     popup.style.left = initialX + 'px';
     popup.style.transform = 'none';
   }
   ```

2. USE ABSOLUTE POSITIONING FOR DRAGGING:
   ```javascript
   function drag(e) {
     if (isDragging) {
       e.preventDefault();
       
       const newX = e.clientX - startX;
       const newY = e.clientY - startY;
       
       popup.style.left = newX + 'px';
       popup.style.top = newY + 'px';
     }
   }
   ```

3. PROPER INITIAL POSITIONING:
   ```javascript
   // Set initial centered position
   popup.style.top = '50%';
   popup.style.left = '50%';
   popup.style.transform = 'translate(-50%, -50%)';
   ```

CODE CHANGES:
=============
1. Modified `makePopupDraggable()` function in script.js:
   - Added proper initial positioning setup
   - Fixed `dragStart()` to get actual popup position using `getBoundingClientRect()`
   - Calculate mouse offset relative to popup position
   - Remove centering transform and switch to absolute positioning
   - Use `top` and `left` properties instead of `transform` for dragging

2. Key improvements:
   - Get actual popup position before dragging starts
   - Calculate mouse offset relative to popup, not screen
   - Clean transition from centering transform to absolute positioning
   - Use consistent positioning method throughout dragging

KEY LEARNINGS:
==============
1. Don't mix `transform` and `top/left` positioning methods for draggable elements
2. Always get the actual element position using `getBoundingClientRect()` before starting drag
3. Calculate mouse offset relative to the element, not the screen
4. Make a clean transition from initial positioning to dragging positioning
5. Use absolute positioning (`top`/`left`) for dragging instead of `transform`

PREVENTION:
===========
- When making elements draggable, always get their actual position first
- Don't mix positioning methods (transform vs top/left)
- Calculate mouse offset relative to the element being dragged
- Make a clean transition from initial positioning to dragging positioning
- Test dragging behavior thoroughly to ensure smooth, predictable movement

RELATED FILES:
=============
- script.js (main file with draggable popup logic)

FUTURE REFERENCE:
================
When implementing draggable popups:
1. Set initial position with CSS (centered or fixed position)
2. In dragStart: Get actual position using `getBoundingClientRect()`
3. Calculate mouse offset relative to the popup position
4. Remove initial positioning transform and switch to absolute positioning
5. Use `top` and `left` properties for dragging, not `transform`
6. Test dragging behavior to ensure smooth, predictable movement

DRAGGABLE POPUP PATTERN:
========================
```javascript
function makePopupDraggable(popup) {
  let isDragging = false;
  let startX, startY, initialX, initialY;

  // Set initial centered position
  popup.style.top = '50%';
  popup.style.left = '50%';
  popup.style.transform = 'translate(-50%, -50%)';

  function dragStart(e) {
    isDragging = true;
    
    // Get actual position
    const rect = popup.getBoundingClientRect();
    initialX = rect.left;
    initialY = rect.top;
    
    // Calculate mouse offset
    startX = e.clientX - initialX;
    startY = e.clientY - initialY;
    
    // Switch to absolute positioning
    popup.style.top = initialY + 'px';
    popup.style.left = initialX + 'px';
    popup.style.transform = 'none';
  }

  function drag(e) {
    if (isDragging) {
      e.preventDefault();
      const newX = e.clientX - startX;
      const newY = e.clientY - startY;
      popup.style.left = newX + 'px';
      popup.style.top = newY + 'px';
    }
  }
}
```

=====================================

INCIDENT: Conditional Logic Implementation Documentation
DATE: [Current Date]
ISSUE ID: CONDITIONAL_LOGIC_DOC_001

PURPOSE:
========
This documentation explains how conditional logic works in the FormWiz GUI system. Conditional logic allows questions to be shown or hidden based on answers to previous questions. This documentation is intended to serve as a reference when implementing conditional logic for new question types.

OVERVIEW:
=========
Conditional logic in FormWiz uses a "show if" pattern:
- A question can have conditional logic enabled
- When enabled, the question is hidden by default
- The question is shown only when specific conditions are met
- Conditions are based on answers to previous questions
- Multiple conditions can be combined with OR logic (if ANY condition matches, show the question)

EXAMPLE SCENARIO:
=================
Given this JSON configuration:
```json
{
  "questionId": 1,
  "text": "Hungry?",
  "type": "dropdown",
  "logic": {
    "enabled": false,
    "conditions": []
  },
  "options": ["Yes", "No"]
},
{
  "questionId": 2,
  "text": "Thirsty?",
  "type": "dropdown",
  "logic": {
    "enabled": true,
    "conditions": [
      {
        "prevQuestion": "1",
        "prevAnswer": "Yes"
      }
    ]
  },
  "options": ["Yes", "No"]
},
{
  "questionId": 3,
  "text": "Sleepy?",
  "type": "dropdown",
  "logic": {
    "enabled": true,
    "conditions": [
      {
        "prevQuestion": "1",
        "prevAnswer": "No"
      }
    ]
  },
  "options": ["Yes", "No"]
}
```

Result:
- Question 1 ("Hungry?") is always visible (no conditional logic)
- Question 2 ("Thirsty?") is hidden until user selects "Yes" in Question 1
- Question 3 ("Sleepy?") is hidden until user selects "No" in Question 1

JSON STRUCTURE:
===============
The conditional logic configuration is stored in the question object:

```json
{
  "questionId": 2,
  "logic": {
    "enabled": true,           // Boolean: Is conditional logic enabled?
    "conditions": [            // Array: List of conditions (OR logic)
      {
        "prevQuestion": "1",   // String: ID of the previous question to check
        "prevAnswer": "Yes"    // String: Answer value that triggers this question
      }
    ]
  }
}
```

KEY PROPERTIES:
---------------
- `logic.enabled`: Boolean flag indicating if conditional logic is active
- `logic.conditions`: Array of condition objects
- `condition.prevQuestion`: Question ID (as string) of the question to check
- `condition.prevAnswer`: Answer value (as string) that must match

IMPLEMENTATION FLOW:
====================

PHASE 1: GUI CONFIGURATION (gui.js)
------------------------------------
Location: FormWiz GUI/gui.js

1. USER INTERFACE SETUP:
   - When user enables conditional logic checkbox, a UI is shown
   - User can add multiple condition rows
   - Each row has:
     - "Previous Question" input: User enters question number (e.g., "1")
     - "Previous Answer" dropdown: Populated based on selected question type

2. QUESTION TYPE DETECTION:
   Function: `updateLogicAnswersForRow(questionId, conditionIndex)`
   - Reads the question number from input field
   - Finds the target question block: `document.getElementById('questionBlock' + prevQNum)`
   - Gets question type: `targetQuestionBlock.querySelector('#questionType' + prevQNum)?.value`

3. ANSWER OPTIONS POPULATION:
   Based on question type, different options are populated:
   
   - **Radio/Yes-No**: Shows "Yes" and "No" options
   - **Dropdown**: Iterates through dropdown options from the question
   - **Checkbox**: Shows all checkbox options + "None of the above" if enabled
   - **Numbered Dropdown**: Shows range of numbers (min to max)
   - **Text/Date/Money**: Hides dropdown, shows label "Will trigger when any text is entered"

4. CONDITION DATA STORAGE:
   When user saves the form, conditions are extracted:
   ```javascript
   const logicRows = qBlock.querySelectorAll(".logic-condition-row");
   logicRows.forEach((row, index) => {
     const prevQuestion = row.querySelector(`#prevQuestion${questionId}_${index+1}`).value;
     const prevAnswer = row.querySelector(`#prevAnswer${questionId}_${index+1}`).value;
     conditions.push({ prevQuestion, prevAnswer });
   });
   ```

PHASE 2: HTML GENERATION (generate.js)
---------------------------------------
Location: FormWiz GUI/generate.js
Lines: ~1956-2054

1. HTML STRUCTURE CREATION:
   - Each question is wrapped in a container: `<div id="question-container-{questionId}">`
   - Questions with conditional logic get the "hidden" class initially:
     ```html
     <div id="question-container-2" class="question-container hidden">
     ```

2. JAVASCRIPT GENERATION:
   For each question with conditional logic enabled, a self-executing function is generated:

   ```javascript
   (function(){
     var thisQ = document.getElementById("question-container-2");
     
     function updateVisibility(){
       var anyMatch = false;
       
       // For each condition, check if it matches
       (function(){
         var cPrevType = "dropdown";
         var cPrevAns = "yes";
         var cPrevQNum = "1";
         
         if(cPrevType === "checkbox"){
           // Checkbox handling (see below)
         } else {
           // Other question types (see below)
         }
       })();
       
       // Show or hide based on match
       if(anyMatch){
         thisQ.classList.remove("hidden");
       } else {
         thisQ.classList.add("hidden");
       }
     }
     
     // Attach event listeners to trigger question
     // Call updateVisibility() on page load
   })();
   ```

3. CONDITION CHECKING LOGIC:
   
   A. CHECKBOX QUESTIONS:
   ```javascript
   if(cPrevType === "checkbox"){
     var questionContainer = document.getElementById('question-container-' + cPrevQNum);
     var cbs = questionContainer ? questionContainer.querySelectorAll('input[type="checkbox"], input[type="radio"]') : [];
     var checkedVals = [];
     for(var cc=0; cc<cbs.length; cc++){
       if(cbs[cc].checked) {
         checkedVals.push(cbs[cc].value.trim().toLowerCase());
       }
     }
     if(checkedVals.indexOf(cPrevAns) !== -1){
       anyMatch = true;
     }
   }
   ```
   
   B. DROPDOWN/TEXT/OTHER QUESTIONS:
   ```javascript
   else {
     var el2 = document.getElementById(questionNameIds[cPrevQNum]) || 
               document.getElementById("answer" + cPrevQNum);
     if(el2){
       var val2 = el2.value.trim().toLowerCase();
       if(val2 === cPrevAns){
         anyMatch = true;
       }
     }
   }
   ```

4. ELEMENT IDENTIFICATION:
   The system uses a `questionNameIds` object to map question IDs to their actual DOM element IDs:
   ```javascript
   var questionNameIds = {"1":"hungry","2":"thristy","3":"sleepy"};
   ```
   
   Element lookup priority:
   1. `document.getElementById(questionNameIds[questionId])` - Preferred (uses nameId)
   2. `document.getElementById("answer" + questionId)` - Fallback (uses default ID)

5. EVENT LISTENER ATTACHMENT:
   After generating the condition checking logic, event listeners are attached to the trigger question:
   
   ```javascript
   // For checkbox questions
   var questionContainer = document.getElementById('question-container-' + selectQuestion);
   var cbs = questionContainer ? questionContainer.querySelectorAll('input[type="checkbox"], input[type="radio"]') : [];
   for(var i=0; i<cbs.length; i++){
     cbs[i].addEventListener("change", function(){ updateVisibility(); });
   }
   
   // For dropdown/select questions
   var el3 = document.getElementById(questionNameIds[selectQuestion]) || 
             document.getElementById("answer" + selectQuestion);
   if(el3){
     el3.addEventListener("change", function(){ updateVisibility(); });
   }
   
   // For text input questions
   var el3 = document.getElementById(questionNameIds[textQuestion]) || 
             document.getElementById("answer" + textQuestion);
   if(el3){
     el3.addEventListener("input", function(){ updateVisibility(); });
   }
   ```

6. INITIAL VISIBILITY CHECK:
   After all event listeners are attached, `updateVisibility()` is called immediately:
   ```javascript
   updateVisibility();
   ```
   This ensures questions are shown/hidden correctly on page load.

PHASE 3: RUNTIME EXECUTION (Generated HTML)
--------------------------------------------
Location: Generated output.html

1. PAGE LOAD:
   - All question containers are rendered
   - Questions with conditional logic have "hidden" class
   - Self-executing functions run immediately
   - `updateVisibility()` is called for each conditional question
   - Initial visibility is set based on current form state

2. USER INTERACTION:
   When user changes an answer in a trigger question:
   - Event listener fires (change event for dropdowns, input event for text)
   - `updateVisibility()` function is called
   - All conditions are checked
   - If ANY condition matches (`anyMatch = true`), question is shown
   - If NO conditions match (`anyMatch = false`), question is hidden

3. MULTIPLE CONDITIONS (OR LOGIC):
   If a question has multiple conditions:
   ```json
   "conditions": [
     {"prevQuestion": "1", "prevAnswer": "Yes"},
     {"prevQuestion": "2", "prevAnswer": "No"}
   ]
   ```
   The question is shown if EITHER condition matches (OR logic).

SPECIAL CASES:
==============

1. TEXT/INPUT QUESTIONS:
   - For text, date, money, and dateRange questions, there are no predefined options
   - Special condition values are used: "Any Text", "Any Amount", "Any Date"
   - These check for presence of any value, not exact match:
   ```javascript
   if(paVal.toLowerCase() === "any text" || 
      paVal.toLowerCase() === "any amount" || 
      paVal.toLowerCase() === "any date"){
     if(el2){
       var val2 = el2.value.trim();
       if(val2 !== ""){
         anyMatch = true;
       }
     }
   }
   ```

2. CHECKBOX QUESTIONS:
   - Checkboxes can have multiple checked options
   - The system checks if ANY checked option matches the condition
   - Works for both regular checkboxes and "Mark Only One" (radio buttons)

3. NUMBERED DROPDOWN QUESTIONS:
   - Condition answer is compared as a string (e.g., "1", "2", "3")
   - The actual value in the form is the selected number from the range

4. CASE INSENSITIVITY:
   - All comparisons use `.toLowerCase()` for case-insensitive matching
   - "Yes" matches "yes", "YES", "YeS", etc.

5. QUESTION NAME IDS:
   - The `questionNameIds` object maps question IDs to their actual DOM element IDs
   - This allows questions to have custom IDs (from `nameId` field) instead of default "answer{N}"
   - Lookup tries `questionNameIds[questionId]` first, then falls back to `"answer" + questionId`

VISIBILITY CSS:
===============
The "hidden" class is defined in the generated HTML:
```css
.hidden {
  display: none !important;
}
```

When a condition matches:
- `thisQ.classList.remove("hidden")` - Shows the question
When no conditions match:
- `thisQ.classList.add("hidden")` - Hides the question

IMPLEMENTING CONDITIONAL LOGIC FOR NEW QUESTION TYPES:
=======================================================

STEP 1: UPDATE GUI CONFIGURATION (gui.js)
------------------------------------------
1. In `updateLogicAnswersForRow()` function, add handling for your new question type:
   ```javascript
   } else if (questionType === 'yourNewType') {
     // Populate answer options based on your question type
     const options = getOptionsForYourNewType(prevQNum);
     options.forEach(option => {
       const optionEl = document.createElement('option');
       optionEl.value = option;
       optionEl.textContent = option;
       answerSelect.appendChild(optionEl);
     });
   }
   ```

STEP 2: UPDATE HTML GENERATION (generate.js)
---------------------------------------------
1. In the condition checking logic (around line 1985), add handling:
   ```javascript
   } else if (cPrevType === "yourNewType") {
     // Add logic to check if condition matches
     var el2 = document.getElementById(questionNameIds[cPrevQNum]) || 
               document.getElementById("answer" + cPrevQNum);
     if(el2){
       var val2 = el2.value.trim().toLowerCase();
       if(val2 === cPrevAns){
         anyMatch = true;
       }
     }
   }
   ```

2. In the event listener attachment section (around line 2030), add handling:
   ```javascript
   } else if (pType2 === "yourNewType") {
     logicScriptBuffer += ` (function(){\n`;
     logicScriptBuffer += `   var yourNewTypeQuestion = "${pqVal2}";\n`;
     logicScriptBuffer += `   var el3= document.getElementById(questionNameIds[yourNewTypeQuestion]) || document.getElementById("answer"+yourNewTypeQuestion);\n`;
     logicScriptBuffer += `   if(el3){ el3.addEventListener("change", function(){ updateVisibility();});}\n`;
     logicScriptBuffer += ` })();\n`;
   }
   ```
   
   Note: Use "change" event for dropdowns/selects, "input" event for text fields

STEP 3: ENSURE PROPER ELEMENT IDS
-----------------------------------
1. Make sure your question type generates elements with proper IDs
2. The ID should either:
   - Be stored in `questionNameIds` object (if using `nameId` field)
   - Or follow the pattern `"answer" + questionId`

STEP 4: TEST THOROUGHLY
------------------------
1. Test with multiple conditions (OR logic)
2. Test with different answer values
3. Test case sensitivity
4. Test on page load (initial visibility)
5. Test when user changes answers
6. Test with multiple questions depending on the same trigger question

COMMON PITFALLS:
================

1. WRONG EVENT TYPE:
   - Using "input" for dropdowns (should use "change")
   - Using "change" for text fields (should use "input")
   - Solution: Check what type of element your question generates

2. WRONG ELEMENT ID:
   - Not using `questionNameIds` lookup
   - Hardcoding element IDs
   - Solution: Always use: `questionNameIds[questionId] || "answer" + questionId`

3. CASE SENSITIVITY:
   - Forgetting to use `.toLowerCase()` in comparisons
   - Solution: Always compare lowercased values

4. CHECKBOX HANDLING:
   - Treating checkboxes like dropdowns
   - Solution: Use special checkbox handling that checks all checked values

5. INITIAL VISIBILITY:
   - Forgetting to call `updateVisibility()` on page load
   - Solution: Always include `updateVisibility();` after event listener setup

DEBUGGING:
==========
The generated code includes console.log statements for debugging:
```javascript
console.log('🔧 [CONDITIONAL DEBUG] Question 1: Found', cbs.length, 'inputs in container, looking for:', cPrevAns);
console.log('🔧 [CONDITIONAL DEBUG] Checked values:', checkedVals, 'Looking for:', cPrevAns);
console.log('🔧 [CONDITIONAL DEBUG] ✅ MATCH FOUND!');
```

To debug conditional logic:
1. Open browser console
2. Change answers in trigger questions
3. Look for conditional debug messages
4. Check if `anyMatch` is being set correctly
5. Verify element IDs are correct
6. Check if event listeners are firing

SUMMARY:
========
Conditional logic in FormWiz works by:
1. Storing conditions in JSON (prevQuestion, prevAnswer)
2. Generating JavaScript that checks conditions on page load and when answers change
3. Using CSS class "hidden" to show/hide questions
4. Supporting OR logic (multiple conditions, any can match)
5. Using case-insensitive matching
6. Supporting special question types (checkbox, text, etc.)

KEY FILES:
==========
- FormWiz GUI/gui.js: GUI configuration and condition setup
- FormWiz GUI/generate.js: HTML/JavaScript generation (lines ~1956-2054)
- Generated output.html: Runtime execution

KEY FUNCTIONS:
==============
- `updateLogicAnswersForRow()`: Populates answer options based on question type
- Condition checking logic: Generated in `generate.js`, executed in output.html
- `updateVisibility()`: Shows/hides questions based on conditions

RELATED FILES:
=============
- FormWiz GUI/gui.js (GUI configuration)
- FormWiz GUI/generate.js (HTML generation)
- FormWiz GUI/output.html (generated form with runtime logic)

FUTURE REFERENCE:
=================
When implementing conditional logic for new question types:
1. Add question type handling in `updateLogicAnswersForRow()` in gui.js
2. Add condition checking logic in generate.js (around line 1985)
3. Add event listener attachment in generate.js (around line 2030)
4. Ensure proper element IDs are generated
5. Test thoroughly with multiple conditions and scenarios
6. Use the debugging console.log statements to verify behavior

=====================================

INCIDENT: Conditional Logic for Date Fields in Trigger Sequences Not Working
DATE: [Current Date]
ISSUE ID: CONDITIONAL_LOGIC_DATE_FIELDS_001

PROBLEM DESCRIPTION:
===================
Date fields within trigger sequences had conditional logic configured, but the date field was always visible even when the required checkbox was not checked. The conditional logic was defined in the GUI JSON (output.json) with `conditionalLogic: { enabled: true, conditions: [...] }`, but when the HTML was generated, the date field appeared regardless of checkbox state.

WHAT WE WERE ATTEMPTING TO DO:
=============================
- Make date fields within trigger sequences conditionally visible based on checkbox selections
- Only show the date field when the user checks the specified checkbox option
- Hide the date field by default when conditional logic is enabled
- Ensure the conditional logic data flows correctly from GUI JSON → unifiedFieldsMap → generated HTML

ISSUES ENCOUNTERED:
==================
1. CONDITIONAL LOGIC DATA NOT IN UNIFIEDFIELDSMAP:
   - When `generate.js` built the `unifiedFieldsMap` from the GUI editor's DOM, it wasn't reading `conditionalLogic` from `window.triggerDateConditionalLogic`
   - The date field in `triggerFields` array was missing the `conditionalLogic` property
   - This caused `createTriggerFieldsContainer` to receive date fields without conditional logic data
   - Result: `triggerField.conditionalLogic` was `undefined` in the generated HTML

2. DATA FLOW GAP:
   - `download.js` correctly stored `conditionalLogic` in `window.triggerDateConditionalLogic` when importing GUI JSON
   - But `generate.js` was building `triggerFields` by reading from the DOM, not from `window.triggerDateConditionalLogic`
   - The conditional logic data existed in memory but wasn't being used when building the trigger fields

3. INITIAL HIDING ISSUE:
   - Even when conditional logic was eventually detected, the date field wasn't being hidden initially
   - The field was visible on page load even when no checkboxes were checked

TECHNICAL DETAILS:
==================
- File: FormWiz GUI/generate.js
- Function: Building `triggerFields` array (around line 1710-1740)
- The code was creating date field objects like this:
  ```javascript
  triggerFields.push({
    type: 'date',
    label: dateLabelEl.value.trim(),
    nodeId: dateNodeIdEl.value.trim()
    // Missing: conditionalLogic property
  });
  ```
- `window.triggerDateConditionalLogic` structure:
  ```javascript
  {
    "2_4_1_1": {  // Key format: questionId_fieldOrder_sequenceIndex_triggerFieldCount
      enabled: true,
      conditions: ["is_this_plaintiff_a_business_yes_what_do_they_do_business_as_an_individual"]
    }
  }
  ```

SOLUTION THAT WORKED:
====================
1. READ CONDITIONAL LOGIC WHEN BUILDING TRIGGER FIELDS:
   ```javascript
   } else if (dateLabelEl && dateNodeIdEl) {
     // Trigger date field
     const dateField = {
       type: 'date',
       label: dateLabelEl.value.trim(),
       nodeId: dateNodeIdEl.value.trim()
     };
     
     // Check for conditional logic from window.triggerDateConditionalLogic
     const triggerFieldCount = fieldIndex + 1;
     const conditionalLogicKey = `${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`;
     if (window.triggerDateConditionalLogic && window.triggerDateConditionalLogic[conditionalLogicKey]) {
       const storedLogic = window.triggerDateConditionalLogic[conditionalLogicKey];
       if (storedLogic.enabled && storedLogic.conditions && storedLogic.conditions.length > 0) {
         dateField.conditionalLogic = {
           enabled: storedLogic.enabled,
           conditions: storedLogic.conditions.filter(c => c && c.trim() !== '')
         };
       }
     }
     
     triggerFields.push(dateField);
   }
   ```

2. ENSURED INITIAL HIDING:
   - In `createTriggerFieldsContainer` function (in generated HTML), the date field is now hidden immediately when conditional logic is enabled:
   ```javascript
   if (hasConditionalLogic) {
     fieldDiv.style.cssText = '... display: none; ...';
   }
   ```

3. CLEANED UP CONSOLE LOGS:
   - Removed excessive debugging logs
   - Kept only essential logs for conditional logic debugging

CODE CHANGES:
=============
1. In FormWiz GUI/generate.js (around line 1710-1740):
   - Modified date field creation to check `window.triggerDateConditionalLogic`
   - Added logic to read conditional logic data using the correct key format
   - Added `conditionalLogic` property to date field object if found
   - Added debug logging to trace the conditional logic lookup

2. In FormWiz GUI/generate.js (around line 2566-2680):
   - Already had conditional logic implementation in `createTriggerFieldsContainer`
   - Ensured field is hidden immediately when conditional logic is enabled
   - Simplified console logs to reduce noise

KEY LEARNINGS:
==============
1. When building data structures from multiple sources (DOM + window variables), ensure all sources are checked
2. The key format for `window.triggerDateConditionalLogic` must match exactly: `questionId_fieldOrder_sequenceIndex_triggerFieldCount`
3. Conditional logic data stored in `window.triggerDateConditionalLogic` during import needs to be read when generating HTML
4. Always hide fields initially when conditional logic is enabled, then show them when conditions are met
5. Use multiple delayed checks (100ms, 500ms, 1000ms, 2000ms) to catch checkboxes that might be created after the date field

PREVENTION:
===========
- When importing GUI JSON, ensure conditional logic data is stored in a format that `generate.js` can read
- When building trigger fields, always check for conditional logic data in `window.triggerDateConditionalLogic`
- Use consistent key formats across all functions (download.js, generate.js, etc.)
- Test that conditional logic data flows correctly: GUI JSON → window variable → unifiedFieldsMap → generated HTML
- Always hide fields initially when conditional logic is enabled

RELATED FILES:
=============
- FormWiz GUI/generate.js (main file - builds triggerFields and generates HTML)
- FormWiz GUI/download.js (stores conditional logic in window.triggerDateConditionalLogic)
- FormWiz GUI/gui.js (manages conditional logic UI in GUI editor)
- FormWiz GUI/output.html (generated HTML with runtime conditional logic)

FUTURE REFERENCE:
================
When implementing conditional logic for trigger sequence fields:
1. Store conditional logic data in `window.triggerDateConditionalLogic` during import (download.js)
2. Read conditional logic data when building triggerFields (generate.js)
3. Use correct key format: `${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`
4. Include `conditionalLogic` property in the field object when building unifiedFieldsMap
5. In generated HTML, hide fields initially when conditional logic is enabled
6. Use retry logic to attach event listeners to checkboxes that might not exist yet
7. Use multiple delayed checks to catch checkboxes created after the conditional field

KEY FORMAT REFERENCE:
=====================
- Key format: `${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`
- Example: `2_4_1_1` means:
  - questionId: 2
  - fieldOrder: 4
  - sequenceIndex: 0 (shown as 1 in key, but 0-based in code)
  - triggerFieldCount: 1 (1-based index)

DATA FLOW:
==========
1. User configures conditional logic in GUI editor → stored in GUI JSON
2. GUI JSON imported → `download.js` stores in `window.triggerDateConditionalLogic`
3. HTML generation → `generate.js` reads from `window.triggerDateConditionalLogic`
4. Data included in `unifiedFieldsMap` → embedded in generated HTML
5. Runtime → `createTriggerFieldsContainer` receives date field with `conditionalLogic`
6. Conditional logic executed → date field shown/hidden based on checkbox state

=====================================

INCIDENT: Conditional Logic for Date Fields in Trigger Sequences Not Updating When Radio Selection Changes
DATE: [Current Date]
ISSUE ID: CONDITIONAL_LOGIC_RADIO_UPDATE_001

PROBLEM DESCRIPTION:
===================
Date fields within trigger sequences had conditional logic that worked correctly when a radio button was initially selected, but failed to hide the date field when the user changed their radio selection. Specifically:

1. Firebase autofilled a radio button (e.g., `is_this_plaintiff_a_business_yes_what_do_they_do_business_as_an_individual_1`)
2. The date field correctly appeared (e.g., `is_this_plaintiff_a_business_yes_when_does_their_business_statement_expire_1`)
3. When the user clicked a different radio button (e.g., `is_this_plaintiff_a_business_yes_what_do_they_do_business_as_an_association_1`), the date field did NOT hide
4. The date field remained visible even though the condition was no longer met

The conditional logic was configured correctly in the GUI JSON with:
```json
"conditionalLogic": {
  "enabled": true,
  "conditions": ["is_this_plaintiff_a_business_yes_what_do_they_do_business_as_an_individual"]
}
```

WHAT WE WERE ATTEMPTING TO DO:
=============================
- Make date fields within trigger sequences conditionally visible based on "Mark only one" checkbox selections (radio buttons)
- Show the date field when the user selects the specified radio button
- Hide the date field when the user selects a different radio button (unchecking the original one)
- Ensure the conditional logic re-evaluates correctly when ANY radio button in the group changes

ISSUES ENCOUNTERED:
==================
1. EVENT HANDLER NOT RECEIVING EVENTS:
   - The `radioGroupChanged` event was being dispatched correctly when a radio button changed
   - But the handler for entry 1's date field was not receiving the event
   - Console logs showed the handler was set up for entry 2, but receiving events for entry 1
   - The handler was comparing entry numbers and rejecting the event because they didn't match

2. HANDLER SETUP TIMING ISSUE:
   - The `radioGroupHandler` was only being set up inside the `attachListener` function
   - `attachListener` only ran when the specific radio button element was found
   - If the handler found a radio button from a different entry number (e.g., entry 2), it would capture the wrong `entryNumber` in its closure
   - This meant the handler would be listening for entry 2 events, but the date field was for entry 1

3. MISSING HANDLER FOR SOME ENTRIES:
   - If the radio button wasn't found yet when `attachListener` ran, the handler might never be set up
   - The handler needed to be set up immediately when the date field is created, not just when the radio button is found

4. REGEX PATTERN ISSUE IN GENERATED HTML:
   - The generated HTML had a regex pattern: `/radio_group_(d+)/` instead of `/radio_group_(\d+)/`
   - This was causing the entry number extraction to fail (returning `null`)
   - However, the code had a fallback to use the closure's `entryNumber`, which should have worked
   - The real issue was the handler setup, not the regex (though the regex should still be fixed)

TECHNICAL DETAILS:
==================
- File: FormWiz GUI/generate.js
- Function: `createTriggerFieldsContainer` (around line 2749-2846)
- The conditional logic handler was set up like this:
  ```javascript
  conditionalConditions.forEach((conditionNodeId) => {
    const attachListener = (attemptCount = 0) => {
      // ... find radio button ...
      if (element) {
        // ... set up direct listeners ...
        if (isRadio && element.type === 'radio') {
          // ... set up radio group listeners ...
          
          // PROBLEM: radioGroupHandler was only set up here
          const radioGroupHandler = function(event) {
            // ... check entry number match ...
          };
          window.addEventListener('radioGroupChanged', radioGroupHandler);
        }
      }
    };
    attachListener();
  });
  ```

- The problem was that `radioGroupHandler` was only set up when:
  1. The radio button element was found
  2. The radio button was part of the same entry number as expected
  
- But if the handler found a radio from entry 2 when it was looking for entry 1, it would capture entry 2's `entryNumber` in its closure
- This caused the handler to reject events for entry 1 because it was checking for entry 2

SOLUTION THAT WORKED:
====================
1. MOVED `radioGroupHandler` OUTSIDE `attachListener`:
   ```javascript
   // CRITICAL: Always set up radioGroupChanged listener for this entry's date field
   // This ensures we catch radio button changes even if the specific radio hasn't been found yet
   const radioGroupHandler = function(event) {
     console.log('🔍 [CONDITIONAL LOGIC DEBUG] radioGroupChanged event received for date field:', triggerField.nodeId + '_' + entryNumber);
     console.log('🔍 [CONDITIONAL LOGIC DEBUG] Event detail:', event.detail);
     // Compare entry numbers (handle both string and number types)
     const eventEntryNumber = event.detail && event.detail.entryNumber;
     const currentEntryNumber = String(entryNumber);
     const eventEntryNumberStr = eventEntryNumber != null ? String(eventEntryNumber) : null;
     console.log('🔍 [CONDITIONAL LOGIC DEBUG] Comparing entry numbers - event:', eventEntryNumberStr, 'current:', currentEntryNumber, 'match:', eventEntryNumberStr === currentEntryNumber);
     
     if (eventEntryNumber != null && String(eventEntryNumber) === String(entryNumber)) {
       console.log('🔍 [CONDITIONAL LOGIC DEBUG] Entry numbers match! Scheduling checkConditionalLogic with 200ms delay');
       // Use a longer delay to ensure DOM is fully updated (hidden checkboxes removed/created)
       setTimeout(() => {
         console.log('🔍 [CONDITIONAL LOGIC DEBUG] Executing checkConditionalLogic from radioGroupChanged handler');
         checkConditionalLogic();
       }, 200);
     } else {
       console.log('🔍 [CONDITIONAL LOGIC DEBUG] Entry numbers do NOT match - ignoring event');
     }
   };
   window.addEventListener('radioGroupChanged', radioGroupHandler);
   console.log('🔍 [CONDITIONAL LOGIC DEBUG] Added radioGroupChanged event listener for entry:', entryNumber);
   ```

2. SET UP HANDLER IMMEDIATELY WHEN DATE FIELD IS CREATED:
   - The handler is now set up before `attachListener` runs
   - It captures the correct `entryNumber` from the closure when the date field is created
   - It always listens for `radioGroupChanged` events, regardless of whether the radio button has been found yet

3. ADDED VALIDATION IN `attachListener`:
   - When setting up direct listeners on radio buttons, we now validate that the radio group's entry number matches the expected entry number
   - This prevents attaching listeners to the wrong radio group
   ```javascript
   if (isRadio && element.type === 'radio') {
     const radioGroupName = element.name;
     // Extract entry number from radio group name to ensure we're listening to the right group
     const radioGroupEntryMatch = radioGroupName.match(/radio_group_(\d+)/);
     const radioGroupEntryNumber = radioGroupEntryMatch ? parseInt(radioGroupEntryMatch[1]) : entryNumber;
     
     console.log('🔍 [CONDITIONAL LOGIC DEBUG] Setting up listeners for radio group:', radioGroupName, 'Total radios in group, entry number from group name:', radioGroupEntryNumber, 'expected entry number:', entryNumber);
     
     // Only set up listeners if this radio group matches our entry number
     if (radioGroupEntryNumber === entryNumber) {
       // ... set up listeners ...
     } else {
       console.log('🔍 [CONDITIONAL LOGIC DEBUG] Radio group entry number (', radioGroupEntryNumber, ') does not match expected entry number (', entryNumber, ') - skipping listener setup');
     }
   }
   ```

CODE CHANGES:
=============
1. In FormWiz GUI/generate.js (around line 2749-2772):
   - Moved `radioGroupHandler` definition outside of `attachListener` function
   - Set up handler immediately when date field is created (before `attachListener` runs)
   - Ensured handler captures correct `entryNumber` from closure
   - Added extensive debug logging to track event flow

2. In FormWiz GUI/generate.js (around line 2811-2836):
   - Added validation to check radio group entry number before setting up direct listeners
   - Prevents attaching listeners to wrong radio groups
   - Added debug logging to show when listeners are skipped

KEY LEARNINGS:
==============
1. **ALWAYS SET UP EVENT HANDLERS IMMEDIATELY**: When an event handler needs to capture a specific value from a closure (like `entryNumber`), set it up immediately when the closure is created, not inside a function that might run later or with different values.

2. **HANDLER TIMING MATTERS**: If an event handler is set up inside a function that only runs conditionally (like `attachListener`), it might not be set up at all, or it might capture the wrong values from the closure.

3. **VALIDATE BEFORE ATTACHING LISTENERS**: When attaching listeners to elements that might belong to different contexts (like different entry numbers), validate that the element belongs to the correct context before attaching.

4. **USE MULTIPLE EVENT SOURCES**: For conditional logic with radio buttons, use both:
   - Direct listeners on radio buttons (for immediate feedback)
   - `radioGroupChanged` custom event (for cross-entry communication)
   
5. **ENTRY NUMBER ISOLATION**: Each entry number (1, 2, 3, etc.) has its own set of radio buttons and conditional fields. Event handlers must be scoped to the correct entry number to avoid cross-contamination.

6. **CLOSURE CAPTURE TIMING**: The value captured in a closure is the value at the time the closure is created, not when it's executed. If `attachListener` runs with a different `entryNumber` than expected, the handler will capture the wrong value.

PREVENTION:
===========
- When creating event handlers that need to capture closure values, set them up immediately when the closure is created, not inside conditional functions
- Always validate that elements belong to the correct context before attaching listeners
- Use both direct listeners and custom events for complex conditional logic scenarios
- Test conditional logic thoroughly when radio button selections change
- Ensure handlers are set up for all entries, not just the first one found

RELATED FILES:
=============
- FormWiz GUI/generate.js (main file - conditional logic handler setup)
- FormWiz GUI/output.html (generated HTML with runtime conditional logic)

FUTURE REFERENCE:
================
When implementing conditional logic that responds to radio button changes:

1. **SET UP HANDLERS IMMEDIATELY**: 
   ```javascript
   // ✅ CORRECT: Set up handler immediately when date field is created
   const radioGroupHandler = function(event) {
     // Handler captures entryNumber from outer closure
     if (event.detail.entryNumber === entryNumber) {
       checkConditionalLogic();
     }
   };
   window.addEventListener('radioGroupChanged', radioGroupHandler);
   
   // Then set up direct listeners later
   conditionalConditions.forEach((conditionNodeId) => {
     const attachListener = () => {
       // Find radio button and attach direct listeners
     };
     attachListener();
   });
   ```

2. **DON'T SET UP HANDLERS INSIDE CONDITIONAL FUNCTIONS**:
   ```javascript
   // ❌ WRONG: Handler only set up if radio button is found
   const attachListener = () => {
     const radio = document.getElementById(radioId);
     if (radio) {
       const radioGroupHandler = function(event) {
         // This might capture wrong entryNumber if radio belongs to different entry
       };
       window.addEventListener('radioGroupChanged', radioGroupHandler);
     }
   };
   ```

3. **VALIDATE BEFORE ATTACHING LISTENERS**:
   ```javascript
   // ✅ CORRECT: Validate entry number matches before attaching
   const radioGroupEntryMatch = radioGroupName.match(/radio_group_(\d+)/);
   const radioGroupEntryNumber = radioGroupEntryMatch ? parseInt(radioGroupEntryMatch[1]) : entryNumber;
   
   if (radioGroupEntryNumber === entryNumber) {
     // Only attach listeners to correct radio group
     radioGroup.forEach(radio => {
       radio.addEventListener('change', handler);
     });
   }
   ```

4. **USE CUSTOM EVENTS FOR CROSS-ENTRY COMMUNICATION**:
   - Radio button change handler dispatches `radioGroupChanged` event with `entryNumber`
   - All date field handlers listen for this event
   - Each handler checks if the event's `entryNumber` matches its own `entryNumber`
   - This ensures handlers only respond to events for their own entry

5. **DEBUG WITH EXTENSIVE LOGGING**:
   - Log when handlers are set up (which entry number)
   - Log when events are received (which entry number)
   - Log when events are ignored (entry number mismatch)
   - Log when conditional logic is checked and what the result is

PATTERN FOR CONDITIONAL LOGIC WITH RADIO BUTTONS:
=================================================
```javascript
// 1. Create date field with conditional logic
if (hasConditionalLogic && conditionalConditions.length > 0) {
  // 2. Set up radioGroupChanged handler IMMEDIATELY (captures correct entryNumber)
  const radioGroupHandler = function(event) {
    if (event.detail.entryNumber === entryNumber) {
      setTimeout(() => checkConditionalLogic(), 200);
    }
  };
  window.addEventListener('radioGroupChanged', radioGroupHandler);
  
  // 3. Set up direct listeners on radio buttons (for immediate feedback)
  conditionalConditions.forEach((conditionNodeId) => {
    const attachListener = () => {
      const radio = document.getElementById(conditionNodeId + "_" + entryNumber + "_radio");
      if (radio) {
        // Validate radio group belongs to this entry
        const radioGroupEntryMatch = radio.name.match(/radio_group_(\d+)/);
        const radioGroupEntryNumber = radioGroupEntryMatch ? parseInt(radioGroupEntryMatch[1]) : entryNumber;
        
        if (radioGroupEntryNumber === entryNumber) {
          // Attach direct listeners
          radio.addEventListener('change', () => checkConditionalLogic());
        }
      }
    };
    attachListener();
  });
}
```

KEY TAKEAWAY:
=============
The critical issue was **handler setup timing and closure capture**. The `radioGroupHandler` was being set up inside `attachListener`, which meant:
1. It might not be set up at all if the radio button wasn't found
2. It might capture the wrong `entryNumber` if `attachListener` found a radio from a different entry
3. The handler wouldn't receive events for the correct entry number

By moving the handler setup outside `attachListener` and setting it up immediately when the date field is created, we ensure:
1. The handler is always set up
2. It captures the correct `entryNumber` from the closure
3. It receives and processes events for the correct entry number

=====================================

INCIDENT: Hidden Checkbox ID Format for Dropdowns in Numbered Dropdowns
DATE: [Current Date]
ISSUE ID: DROPDOWN_CHECKBOX_ID_FORMAT_001

PROBLEM DESCRIPTION:
===================
Hidden checkboxes generated from dropdowns inside numbered dropdown questions were being created with incorrect ID format. The IDs were being generated as `is_this_plaintiff_a_business_1_yes` instead of the desired format `is_this_plaintiff_a_business_yes_1` (entry number should be last).

The issue affected:
- Dropdowns inside numbered dropdown questions (e.g., "Is this plaintiff a business?" inside "How many extra plantiffs")
- Hidden checkboxes created by `dropdownMirror()` function
- Hidden checkboxes created by `createHiddenCheckboxesForAutofilledDropdowns()` function

WHAT WE WERE ATTEMPTING TO DO:
=============================
- Generate hidden checkbox IDs in the format: `fieldName_optionValue_entryNumber` (entry number last)
- Example: `is_this_plaintiff_a_business_yes_1` instead of `is_this_plaintiff_a_business_1_yes`
- Detect when a dropdown ID ends with an entry number (e.g., `is_this_plaintiff_a_business_1`)
- Extract the field name and entry number correctly
- Format the checkbox ID with entry number last

ISSUES ENCOUNTERED:
==================
1. REGEX PATTERN ESCAPING ISSUE:
   - The code used `/^\d+$/` to detect if the last part of `baseName` was a number
   - When JavaScript code containing regex is embedded in HTML strings, backslashes can be lost
   - The regex `/^\d+$/` was being written as `/^d+$/` in the generated HTML
   - This caused the regex to look for the literal character 'd' followed by '+' instead of digits
   - Result: The code never detected that `baseName` ended with a number, so it treated all dropdowns as regular dropdowns

2. FAILED NUMBER DETECTION:
   - Because the regex failed, `potentialEntryNumber` (e.g., "1") was never detected as numeric
   - The code fell through to the regular dropdown format: `baseName + "_" + idSuffix`
   - This created IDs like `is_this_plaintiff_a_business_1_yes` instead of `is_this_plaintiff_a_business_yes_1`

3. ADDITIONAL REGEX BUG:
   - Line 3319 had `/W+/g` instead of `/\W+/g` (missing backslash)
   - This caused incorrect sanitization of option values
   - The pattern was matching literal 'W' characters instead of non-word characters

TECHNICAL DETAILS:
==================
- File: FormWiz GUI/generate.js
- Functions: `dropdownMirror()` (around line 5572) and `createHiddenCheckboxesForAutofilledDropdowns()` (around line 8684)
- The dropdown ID format for numbered dropdowns: `sanitizedFieldName + "_" + j` (e.g., `is_this_plaintiff_a_business_1`)
- The logic should detect when `baseName` ends with a number to determine it's a numbered dropdown
- When detected, it should extract: `fieldName = "is_this_plaintiff_a_business"`, `entryNumber = "1"`
- Then create checkbox ID as: `fieldName + "_" + idSuffix + "_" + entryNumber`

SOLUTION THAT WORKED:
====================
1. CHANGED REGEX PATTERN TO USE CHARACTER CLASS:
   ```javascript
   // Before (incorrect - backslash gets lost when embedded in HTML):
   if (/^\d+$/.test(potentialEntryNumber)) {
   
   // After (correct - character class doesn't require escaping):
   if (/^[0-9]+$/.test(potentialEntryNumber)) {
   ```

2. FIXED ADDITIONAL REGEX BUG:
   ```javascript
   // Before (missing backslash):
   const idSuffix = val.replace(/W+/g, "_").toLowerCase();
   
   // After (correct):
   const idSuffix = val.replace(/\W+/g, "_").toLowerCase();
   ```

3. ADDED FALLBACK NUMBER DETECTION:
   ```javascript
   // Try multiple ways to check if it's a number
   const isNumeric = /^[0-9]+$/.test(potentialEntryNumber);
   const isNumericAlt = !isNaN(parseInt(potentialEntryNumber)) && potentialEntryNumber === String(parseInt(potentialEntryNumber));
   const isNumericFinal = isNumeric || isNumericAlt;
   ```

4. ENHANCED DEBUGGING:
   - Added extensive console logs to show:
     - The `baseName` being processed
     - The extracted `potentialEntryNumber`
     - Both regex and parseInt test results
     - The final checkbox ID being created

CODE CHANGES:
=============
1. In `dropdownMirror()` function (generate.js, around line 5608):
   - Changed `/^\d+$/` to `/^[0-9]+$/`
   - Fixed `/W+/g` to `/\W+/g`
   - Added fallback number detection using `parseInt`
   - Added extensive debugging logs

2. In `createHiddenCheckboxesForAutofilledDropdowns()` function (generate.js, around line 8709):
   - Changed `/^\d+$/` to `/^[0-9]+$/`
   - Fixed `/W+/g` to `/\W+/g`
   - Added fallback number detection using `parseInt`
   - Added extensive debugging logs

KEY LEARNINGS:
==============
1. **REGEX ESCAPING IN EMBEDDED JAVASCRIPT**: When JavaScript code containing regex patterns is embedded in HTML strings (especially in template literals), backslashes in regex patterns can be lost. Use character classes like `[0-9]` instead of shorthand like `\d` to avoid escaping issues.

2. **CHARACTER CLASSES ARE SAFER**: Character classes like `[0-9]`, `[a-z]`, `[^a-z0-9_]` don't require backslash escaping and are more reliable when code is embedded in strings.

3. **ALWAYS VERIFY GENERATED CODE**: After generating HTML with embedded JavaScript, check that regex patterns are correctly preserved in the output. Look for patterns like `/^d+$/` (wrong) vs `/^[0-9]+$/` (correct).

4. **USE FALLBACK DETECTION**: When detecting numeric values, use multiple methods (regex + parseInt) to ensure reliable detection even if one method fails.

5. **TEST WITH ACTUAL DATA**: Always test regex patterns with actual data to ensure they work correctly in the generated HTML.

PREVENTION:
===========
- When writing regex patterns that will be embedded in HTML strings, use character classes instead of shorthand patterns
- Always use `/\W+/g` (with backslash) not `/W+/g` (without backslash) for non-word character matching
- Test generated HTML to verify regex patterns are correctly preserved
- Use fallback detection methods when checking for numeric values
- Add debugging logs to verify regex patterns are working correctly

RELATED FILES:
=============
- FormWiz GUI/generate.js (main file - dropdownMirror and createHiddenCheckboxesForAutofilledDropdowns functions)
- FormWiz GUI/output.html (generated HTML with embedded JavaScript - where the issue manifests)

FUTURE REFERENCE:
================
When creating regex patterns that will be embedded in HTML strings:

1. **USE CHARACTER CLASSES**:
   ```javascript
   // ✅ CORRECT: Character class doesn't require escaping
   if (/^[0-9]+$/.test(value)) {
   
   // ❌ WRONG: Shorthand requires backslash, may get lost in HTML
   if (/^\d+$/.test(value)) {
   ```

2. **ALWAYS ESCAPE BACKSLASHES PROPERLY**:
   ```javascript
   // ✅ CORRECT: Backslash properly escaped
   const idSuffix = val.replace(/\W+/g, "_").toLowerCase();
   
   // ❌ WRONG: Missing backslash
   const idSuffix = val.replace(/W+/g, "_").toLowerCase();
   ```

3. **USE FALLBACK DETECTION**:
   ```javascript
   // ✅ CORRECT: Multiple detection methods
   const isNumeric = /^[0-9]+$/.test(value);
   const isNumericAlt = !isNaN(parseInt(value)) && value === String(parseInt(value));
   const isNumericFinal = isNumeric || isNumericAlt;
   ```

4. **VERIFY IN GENERATED HTML**:
   - After generating HTML, search for regex patterns
   - Ensure they're correctly preserved (e.g., `/^[0-9]+$/` not `/^d+$/`)
   - Test with actual data to verify they work

5. **COMMON PATTERNS**:
   - `/[0-9]+/` instead of `/\d+/` (digits)
   - `/[a-z0-9_]+/` instead of `/\w+/` (word characters)
   - `/[^a-z0-9_]+/` instead of `/\W+/` (non-word characters)
   - `/[?]/` instead of `/\?/` (question mark)
   - `/[ ]/` instead of `/\s/` (space)

REGEX PATTERN REFERENCE:
========================
When embedding regex in HTML strings, prefer these patterns:

| Intended Pattern | ❌ Risky (backslash escaping) | ✅ Safe (character class) |
|-----------------|-------------------------------|---------------------------|
| Digits | `/\d+/` | `/[0-9]+/` |
| Word characters | `/\w+/` | `/[a-z0-9_]+/` |
| Non-word characters | `/\W+/` | `/[^a-z0-9_]+/` |
| Question mark | `/\?/` | `/[?]/` |
| Space | `/\s/` | `/[ ]/` |

KEY TAKEAWAY:
=============
The issue was caused by **regex pattern escaping when JavaScript is embedded in HTML strings**. The backslash in `\d` was being lost, causing the pattern to match the literal character 'd' instead of digits. By using character classes like `[0-9]` instead of shorthand patterns like `\d`, we avoid the escaping issue entirely and ensure the regex works correctly in the generated HTML.

=====================================

INCIDENT: Making Properties Menu Draggable and Resizable with Dynamic Content Layout
DATE: [Current Date]
ISSUE ID: DRAGGABLE_RESIZABLE_MENU_001

PROBLEM DESCRIPTION:
===================
The properties menu needed to be made draggable and resizable while ensuring that:
1. The content area dynamically adjusts its height when the menu is resized
2. The close button always stays at the bottom, eliminating white space
3. The menu can be dragged by the header
4. The menu can be resized by dragging from edges and corners
5. Content remains scrollable when it exceeds available space

WHAT WE WERE ATTEMPTING TO DO:
=============================
- Make the properties menu draggable by clicking and dragging the header
- Make the menu resizable by dragging from edges and corners
- Ensure content area automatically adjusts to fill available space
- Keep the close button at the bottom at all times
- Prevent white space when menu is resized

TECHNICAL DETAILS:
==================
- File: graph.js
- Function: `makePropertiesPopupDraggable(popup)` (around line 3495)
- Function: `showPropertiesPopup(cell)` (around line 480)
- The popup structure:
  - Header (draggable, flex-shrink: 0)
  - Content area (scrollable, flex: 1)
  - Button container (close button, margin-top: auto, flex-shrink: 0)

SOLUTION THAT WORKED:
====================
1. FLEXBOX LAYOUT STRUCTURE:
   ```javascript
   // Popup container
   popup.style.cssText = `
     display: flex;
     flex-direction: column;
     overflow: hidden;
     height: 600px; // Initial height
     min-height: 400px;
     max-height: 90vh;
   `;
   
   // Header (fixed size, no shrinking)
   header.style.cssText = `
     flex-shrink: 0;
     cursor: move;
   `;
   
   // Content area (grows/shrinks to fill space)
   content.style.cssText = `
     flex: 1;
     overflow-y: auto;
     overflow-x: hidden;
     display: flex;
     flex-direction: column;
   `;
   
   // Button container (pushed to bottom)
   buttonContainer.style.cssText = `
     margin-top: auto;
     flex-shrink: 0;
   `;
   ```

2. DRAGGABLE FUNCTIONALITY:
   ```javascript
   function dragStart(e) {
     // Don't drag when clicking close button or resize handles
     if (e.target.classList.contains('close-btn') || 
         e.target.closest('.close-btn') ||
         e.target.classList.contains('resize-handle') ||
         e.target.closest('.resize-handle')) return;
     
     isDragging = true;
     
     // Get actual position
     const rect = popup.getBoundingClientRect();
     initialX = rect.left;
     initialY = rect.top;
     
     // Calculate mouse offset
     startX = e.clientX - initialX;
     startY = e.clientY - initialY;
     
     // Switch from centered transform to absolute positioning
     popup.style.top = initialY + 'px';
     popup.style.left = initialX + 'px';
     popup.style.transform = 'none';
   }
   
   function handleMouseMove(e) {
     if (isDragging) {
       const newX = e.clientX - startX;
       const newY = e.clientY - startY;
       popup.style.left = newX + 'px';
       popup.style.top = newY + 'px';
     }
   }
   ```

3. RESIZABLE FUNCTIONALITY:
   ```javascript
   // Create resize handles for all edges and corners
   const resizeHandles = ['n', 's', 'e', 'w', 'ne', 'nw', 'se', 'sw'];
   resizeHandles.forEach(direction => {
     const handle = document.createElement('div');
     handle.className = `resize-handle resize-${direction}`;
     handle.style.cssText = `
       position: absolute;
       background: transparent;
       z-index: 10001;
     `;
     
     // Position based on direction
     if (direction.includes('n')) {
       handle.style.top = '0';
       handle.style.height = '8px';
       handle.style.cursor = 'ns-resize';
     }
     if (direction.includes('s')) {
       handle.style.bottom = '0';
       handle.style.height = '8px';
       handle.style.cursor = 'ns-resize';
     }
     if (direction.includes('e')) {
       handle.style.right = '0';
       handle.style.width = '8px';
       handle.style.cursor = 'ew-resize';
     }
     if (direction.includes('w')) {
       handle.style.left = '0';
       handle.style.width = '8px';
       handle.style.cursor = 'ew-resize';
     }
     
     // Corner handles are larger
     if (direction.length === 2) {
       handle.style.width = '12px';
       handle.style.height = '12px';
     }
     
     handle.addEventListener('mousedown', (e) => {
       isResizing = true;
       resizeDirection = direction;
       const rect = popup.getBoundingClientRect();
       initialX = rect.left;
       initialY = rect.top;
       initialWidth = rect.width;
       initialHeight = rect.height;
       startX = e.clientX;
       startY = e.clientY;
     });
     
     popup.appendChild(handle);
   });
   
   function handleMouseMove(e) {
     if (isResizing) {
       const deltaX = e.clientX - startX;
       const deltaY = e.clientY - startY;
       const minWidth = parseInt(popup.style.minWidth) || 500;
       const minHeight = 300;
       
       let newWidth = initialWidth;
       let newHeight = initialHeight;
       let newLeft = initialX;
       let newTop = initialY;
       
       // Handle horizontal resizing
       if (resizeDirection.includes('e')) {
         newWidth = Math.max(minWidth, initialWidth + deltaX);
       }
       if (resizeDirection.includes('w')) {
         newWidth = Math.max(minWidth, initialWidth - deltaX);
         newLeft = initialX + (initialWidth - newWidth);
       }
       
       // Handle vertical resizing
       if (resizeDirection.includes('s')) {
         newHeight = Math.max(minHeight, initialHeight + deltaY);
       }
       if (resizeDirection.includes('n')) {
         newHeight = Math.max(minHeight, initialHeight - deltaY);
         newTop = initialY + (initialHeight - newHeight);
       }
       
       popup.style.width = newWidth + 'px';
       popup.style.height = newHeight + 'px';
       popup.style.left = newLeft + 'px';
       popup.style.top = newTop + 'px';
       popup.style.transform = 'none';
       popup.style.display = 'flex'; // Ensure flex layout is active
     }
   }
   ```

4. DYNAMIC CONTENT ADJUSTMENT:
   - The flexbox layout automatically handles content adjustment
   - `flex: 1` on content area makes it grow/shrink to fill available space
   - `margin-top: auto` on button container pushes it to the bottom
   - `overflow-y: auto` on content area enables scrolling when needed
   - No ResizeObserver needed - flexbox handles it automatically

CODE CHANGES:
=============
1. In `showPropertiesPopup()` function (graph.js, around line 480):
   - Set popup to `display: flex; flex-direction: column;`
   - Set `overflow: hidden` on popup
   - Set initial `height: 600px`, `min-height: 400px`, `max-height: 90vh`
   - Set header to `flex-shrink: 0`
   - Set content to `flex: 1; overflow-y: auto;`
   - Set button container to `margin-top: auto; flex-shrink: 0`

2. Created `makePropertiesPopupDraggable()` function (graph.js, around line 3495):
   - Implemented drag functionality using header
   - Created 8 resize handles (n, s, e, w, ne, nw, se, sw)
   - Implemented resize logic with min-width and min-height constraints
   - Handled both dragging and resizing in same mouse move handler

KEY LEARNINGS:
==============
1. **FLEXBOX IS KEY**: Using flexbox layout (`display: flex; flex-direction: column`) automatically handles dynamic content adjustment. The `flex: 1` property makes the content area grow/shrink to fill available space.

2. **MARGIN-TOP: AUTO**: Using `margin-top: auto` on the button container pushes it to the bottom of the flex container, eliminating the need for JavaScript to calculate positions.

3. **OVERFLOW HANDLING**: Set `overflow: hidden` on the popup container and `overflow-y: auto` on the content area. This ensures scrolling works correctly while preventing content from spilling outside the popup.

4. **RESIZE HANDLES**: Create transparent resize handles positioned absolutely at edges and corners. Use appropriate cursor styles (`ns-resize`, `ew-resize`, `nwse-resize`, `nesw-resize`) for visual feedback.

5. **MINIMUM CONSTRAINTS**: Always enforce minimum width and height when resizing to prevent the popup from becoming too small to use.

6. **TRANSFORM TO ABSOLUTE**: When starting to drag, switch from `transform: translate(-50%, -50%)` (centering) to absolute positioning (`top`/`left`). This prevents teleporting issues.

7. **FLEX DISPLAY ON RESIZE**: When resizing, ensure `display: flex` is set to maintain the flexbox layout. This ensures content continues to adjust dynamically.

PREVENTION:
===========
- Always use flexbox layout for resizable modals with dynamic content
- Set `flex: 1` on content areas that should grow/shrink
- Use `margin-top: auto` to push buttons to the bottom
- Set `overflow: hidden` on container and `overflow-y: auto` on scrollable content
- Create resize handles for all edges and corners for better UX
- Enforce minimum width and height constraints
- Switch from transform-based centering to absolute positioning when dragging starts

RELATED FILES:
=============
- graph.js (main file - makePropertiesPopupDraggable and showPropertiesPopup functions)

FUTURE REFERENCE:
================
To make any menu/popup draggable and resizable with dynamic content:

1. **SET UP FLEXBOX LAYOUT**:
   ```javascript
   popup.style.cssText = `
     display: flex;
     flex-direction: column;
     overflow: hidden;
     height: 600px;
     min-height: 400px;
     max-height: 90vh;
   `;
   ```

2. **STRUCTURE THE CONTENT**:
   ```javascript
   // Header (fixed)
   header.style.cssText = `flex-shrink: 0;`;
   
   // Content (grows/shrinks)
   content.style.cssText = `
     flex: 1;
     overflow-y: auto;
     overflow-x: hidden;
   `;
   
   // Buttons (pushed to bottom)
   buttonContainer.style.cssText = `
     margin-top: auto;
     flex-shrink: 0;
   `;
   ```

3. **IMPLEMENT DRAGGING**:
   ```javascript
   header.addEventListener('mousedown', (e) => {
     if (e.target.classList.contains('close-btn')) return;
     isDragging = true;
     const rect = popup.getBoundingClientRect();
     initialX = rect.left;
     initialY = rect.top;
     startX = e.clientX - initialX;
     startY = e.clientY - initialY;
     popup.style.top = initialY + 'px';
     popup.style.left = initialX + 'px';
     popup.style.transform = 'none';
   });
   ```

4. **IMPLEMENT RESIZING**:
   ```javascript
   const resizeHandles = ['n', 's', 'e', 'w', 'ne', 'nw', 'se', 'sw'];
   resizeHandles.forEach(direction => {
     const handle = document.createElement('div');
     handle.className = `resize-handle resize-${direction}`;
     // Position and style handle...
     handle.addEventListener('mousedown', (e) => {
       isResizing = true;
       resizeDirection = direction;
       // Store initial dimensions and position...
     });
     popup.appendChild(handle);
   });
   ```

5. **HANDLE MOUSE MOVEMENT**:
   ```javascript
   function handleMouseMove(e) {
     if (isResizing) {
       // Calculate new dimensions based on resizeDirection
       // Enforce min-width and min-height
       // Update popup.style.width, height, left, top
       popup.style.display = 'flex'; // Maintain flex layout
     } else if (isDragging) {
       // Calculate new position
       popup.style.left = (e.clientX - startX) + 'px';
       popup.style.top = (e.clientY - startY) + 'px';
     }
   }
   ```

PATTERN FOR DRAGGABLE AND RESIZABLE MENUS:
===========================================
```javascript
function makeMenuDraggableAndResizable(popup) {
  // 1. Set up flexbox layout
  popup.style.cssText = `
    display: flex;
    flex-direction: column;
    overflow: hidden;
    height: 600px;
    min-height: 400px;
    max-height: 90vh;
  `;
  
  // 2. Structure: Header (flex-shrink: 0) + Content (flex: 1) + Buttons (margin-top: auto)
  
  // 3. Make header draggable
  header.addEventListener('mousedown', dragStart);
  
  // 4. Create resize handles
  ['n', 's', 'e', 'w', 'ne', 'nw', 'se', 'sw'].forEach(direction => {
    const handle = createResizeHandle(direction);
    popup.appendChild(handle);
  });
  
  // 5. Handle mouse movement for both dragging and resizing
  document.addEventListener('mousemove', handleMouseMove);
  document.addEventListener('mouseup', handleMouseUp);
}
```

KEY TAKEAWAY:
=============
The key to making menus draggable and resizable with dynamic content is using **flexbox layout** with:
- `flex: 1` on content area (grows/shrinks automatically)
- `margin-top: auto` on button container (pushes to bottom)
- `overflow-y: auto` on content (enables scrolling)
- Resize handles positioned absolutely at edges/corners
- Minimum width/height constraints during resize
- Switching from transform-based centering to absolute positioning when dragging starts

The flexbox layout automatically handles content adjustment - no ResizeObserver or manual height calculations needed!

=====================================