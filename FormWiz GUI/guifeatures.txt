================================================================================
GUI FEATURES DOCUMENTATION
================================================================================
This document provides detailed, step-by-step documentation for GUI features
that can be replicated in other contexts. Each feature is documented with:
- Purpose and behavior
- UI components and layout
- Data storage structure
- Complete implementation details
- Export/import process
- Runtime behavior
- Common patterns and gotchas

================================================================================
FEATURE #1: ENABLE ALERT FOR TRIGGER DROPDOWN FIELDS
================================================================================

PURPOSE:
--------
Allows form builders to configure conditional alerts on dropdown fields within
trigger sequences. When a user selects a specific option in the generated form,
a custom modal alert is displayed with a custom message.

Example: A dropdown "Are they a public entity?" has options "Yes" and "No".
The form builder can enable an alert so that when users select "Yes", they see
an alert message like "public entities are cool".

CONTEXT:
--------
This feature is implemented for dropdown fields within trigger sequences.
Trigger sequences are conditional fields that appear when a parent dropdown
has a specific value. For example, if "Are they a business or public entity?"
is set to "Yes", a trigger sequence appears with additional fields including
the "Are they a public entity?" dropdown.

================================================================================
PART 1: GUI INTERFACE (FormWiz GUI/gui.js)
================================================================================

1.1 ADDING THE UI CHECKBOX
---------------------------
Location: `addTriggerDropdown()` function (around line 3197)

When a dropdown field is added to a trigger sequence, an "Enable Alert" checkbox
is added right after the "Enable Conditional Logic" checkbox.

UI Structure:
```html
<div style="margin-bottom: 8px; text-align: center;">
    <label for="enableAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}">
        Enable Alert
    </label>
    <div style="display: flex; justify-content: center;">
        <input type="checkbox" 
               id="enableAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}"
               onchange="toggleTriggerDropdownAlert({questionId}, {fieldCount}, {sequenceCount}, {triggerFieldCount})">
    </div>
    <div id="alertUIDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}" 
         style="margin-top: 8px; display: none;">
        <!-- Alert UI will be populated here -->
    </div>
</div>
```

Key Patterns:
- Checkbox ID pattern: `enableAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Container ID pattern: `alertUIDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Container is initially hidden (`display: none`)
- The toggle function is called on checkbox `onchange` event

1.2 TOGGLE FUNCTION
-------------------
Location: `toggleTriggerDropdownAlert()` function (around line 3850)

Purpose: Shows/hides the alert configuration UI and manages the data structure.

Function Signature:
```javascript
function toggleTriggerDropdownAlert(questionId, fieldCount, sequenceCount, triggerFieldCount)
```

Implementation Steps:

Step 1: Get DOM Elements
```javascript
const checkbox = document.getElementById(`enableAlertDropdown${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
const container = document.getElementById(`alertUIDropdown${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
```

Step 2: Initialize Data Structure
```javascript
if (!window.triggerDropdownAlert) {
    window.triggerDropdownAlert = {};
}
const key = `${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`;
if (!window.triggerDropdownAlert[key]) {
    window.triggerDropdownAlert[key] = { enabled: false, condition: '', title: '' };
}
```

Step 3: Update Enabled State and Show/Hide UI
```javascript
container.style.display = checkbox.checked ? 'block' : 'none';
window.triggerDropdownAlert[key].enabled = checkbox.checked;
```

Step 4: Call Update Function if Enabled
```javascript
if (checkbox.checked) {
    updateTriggerDropdownAlertUI(questionId, fieldCount, sequenceCount, triggerFieldCount);
} else {
    // Clear alert data when disabled
    window.triggerDropdownAlert[key].condition = '';
    window.triggerDropdownAlert[key].title = '';
}
```

Step 5: Trigger Autosave
```javascript
if (typeof window.requestAutosave === 'function') {
    window.requestAutosave();
}
```

Data Storage Key Pattern:
- Format: `"{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}"`
- Example: `"1_5_1_4"` means question 1, field 5, sequence 1, trigger field 4
- Stored in: `window.triggerDropdownAlert[key]`

1.3 UPDATE UI FUNCTION
----------------------
Location: `updateTriggerDropdownAlertUI()` function (around line 3880)

Purpose: Populates the alert configuration UI with:
1. A dropdown to select which option triggers the alert (populated from the dropdown's options)
2. A text input for the alert message

Function Signature:
```javascript
function updateTriggerDropdownAlertUI(questionId, fieldCount, sequenceCount, triggerFieldCount)
```

Implementation Steps:

Step 1: Get Container and Initialize Data Structure
```javascript
const container = document.getElementById(`alertUIDropdown${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
if (!container) return;

if (!window.triggerDropdownAlert) {
    window.triggerDropdownAlert = {};
}
const key = `${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`;
if (!window.triggerDropdownAlert[key]) {
    window.triggerDropdownAlert[key] = { enabled: true, condition: '', title: '' };
}
```

Step 2: Get Dropdown Options from the Parent Field
```javascript
const optionsContainer = document.getElementById(`triggerDropdownOptions${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
const options = [];
if (optionsContainer) {
    const optionInputs = optionsContainer.querySelectorAll('input[type="text"]');
    optionInputs.forEach(input => {
        const optionText = input.value.trim();
        if (optionText) {
            options.push(optionText);
        }
    });
}
```

Key Pattern: Options are read from the DOM, not from a data structure. This means
the options container must exist and be populated before calling this function.

Step 3: Clear Container and Create Alert Condition Dropdown
```javascript
container.innerHTML = '';

const conditionRow = document.createElement('div');
conditionRow.style.cssText = 'margin-bottom: 8px; display: flex; flex-direction: column; align-items: center; gap: 4px;';

const conditionLabel = document.createElement('label');
conditionLabel.textContent = 'Alert Condition:';
conditionLabel.style.cssText = 'font-weight: bold; color: #333; font-size: 12px;';
conditionRow.appendChild(conditionLabel);

const conditionDropdown = document.createElement('select');
conditionDropdown.style.cssText = 'width: 70%; max-width: 300px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 12px;';

// Add placeholder option
const placeholderOption = document.createElement('option');
placeholderOption.value = '';
placeholderOption.textContent = 'Select option...';
conditionDropdown.appendChild(placeholderOption);

// Add options from the dropdown field
options.forEach(optionText => {
    const option = document.createElement('option');
    option.value = optionText;
    option.textContent = optionText;
    if (window.triggerDropdownAlert[key].condition === optionText) {
        option.selected = true;
    }
    conditionDropdown.appendChild(option);
});
```

Step 4: Add Change Handler for Condition Dropdown
```javascript
conditionDropdown.value = window.triggerDropdownAlert[key].condition || '';
conditionDropdown.onchange = () => {
    if (!window.triggerDropdownAlert[key]) {
        window.triggerDropdownAlert[key] = { enabled: true, condition: '', title: '' };
    }
    window.triggerDropdownAlert[key].condition = conditionDropdown.value;
    // Trigger autosave
    if (typeof window.requestAutosave === 'function') {
        window.requestAutosave();
    }
};
conditionRow.appendChild(conditionDropdown);
container.appendChild(conditionRow);
```

Step 5: Create Alert Title Input
```javascript
const titleRow = document.createElement('div');
titleRow.style.cssText = 'margin-bottom: 8px; display: flex; flex-direction: column; align-items: center; gap: 4px;';

const titleLabel = document.createElement('label');
titleLabel.textContent = 'Alert Title:';
titleLabel.style.cssText = 'font-weight: bold; color: #333; font-size: 12px;';
titleRow.appendChild(titleLabel);

const titleInput = document.createElement('input');
titleInput.type = 'text';
titleInput.placeholder = 'Enter alert message...';
titleInput.style.cssText = 'width: 70%; max-width: 300px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 12px;';
titleInput.value = window.triggerDropdownAlert[key].title || '';
```

Step 6: Add Change/Blur Handlers for Title Input
```javascript
titleInput.onchange = () => {
    if (!window.triggerDropdownAlert[key]) {
        window.triggerDropdownAlert[key] = { enabled: true, condition: '', title: '' };
    }
    window.triggerDropdownAlert[key].title = titleInput.value.trim();
    if (typeof window.requestAutosave === 'function') {
        window.requestAutosave();
    }
};
titleInput.onblur = () => {
    // Same as onchange - ensures data is saved even if user tabs away
    if (!window.triggerDropdownAlert[key]) {
        window.triggerDropdownAlert[key] = { enabled: true, condition: '', title: '' };
    }
    window.triggerDropdownAlert[key].title = titleInput.value.trim();
    if (typeof window.requestAutosave === 'function') {
        window.requestAutosave();
    }
};
titleRow.appendChild(titleInput);
container.appendChild(titleRow);
```

Important Patterns:
- Both `onchange` and `onblur` handlers are used to ensure data is saved
- Always check if the data structure exists before accessing it
- Always trigger autosave after data changes
- The condition dropdown is populated from the actual dropdown options in the DOM

================================================================================
PART 2: EXPORT/IMPORT (FormWiz GUI/download.js)
================================================================================

2.1 EXPORT PROCESS
------------------
Location: Field collection code in `getFormJSON()` function (around line 1885-1950)

When collecting trigger dropdown field data for JSON export, alert data must be
collected from `window.triggerDropdownAlert` and added to the `dropdownField` object.

Implementation:

Step 1: Find the Alert Data
```javascript
// After collecting dropdown options and conditional logic
const dropdownField = {
    type: 'dropdown',
    fieldName: dropdownFieldNameEl.value.trim(),
    options: dropdownOptions
};

// Check for alert data
const alertKey = `${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`;
let alertEnabled = false;
let storedAlertData = null;

if (window.triggerDropdownAlert && window.triggerDropdownAlert[alertKey]) {
    const storedAlert = window.triggerDropdownAlert[alertKey];
    alertEnabled = storedAlert.enabled || false;
    if (alertEnabled && (storedAlert.condition || storedAlert.title)) {
        storedAlertData = {
            condition: storedAlert.condition || '',
            title: storedAlert.title || ''
        };
    }
}
```

Step 2: Check Checkbox State as Fallback
```javascript
// Also check checkbox state as fallback
if (!alertEnabled) {
    const enableAlertCheckbox = fieldEl.querySelector(`#enableAlertDropdown${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`);
    alertEnabled = enableAlertCheckbox && enableAlertCheckbox.checked;
}
```

Step 3: Add Alert Data to Field Object
```javascript
// Include alert if enabled
if (alertEnabled && storedAlertData) {
    dropdownField.alert = {
        enabled: true,
        condition: storedAlertData.condition,
        title: storedAlertData.title
    };
} else if (alertEnabled) {
    // Fallback: try to get from UI elements
    const alertContainer = fieldEl.querySelector(`#alertUIDropdown${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`);
    if (alertContainer) {
        const conditionDropdown = alertContainer.querySelector('select');
        const titleInput = alertContainer.querySelector('input[type="text"]');
        if (conditionDropdown && titleInput) {
            const condition = conditionDropdown.value.trim();
            const title = titleInput.value.trim();
            if (condition || title) {
                dropdownField.alert = {
                    enabled: true,
                    condition: condition,
                    title: title
                };
            }
        }
    }
}
```

Key Pattern: Export checks both `window.triggerDropdownAlert` (preferred) and
UI elements (fallback) to ensure data is captured even if the window object
isn't up to date.

JSON Export Format:
```json
{
    "type": "dropdown",
    "fieldName": "Are they a public entity?",
    "options": [
        {"text": "Yes"},
        {"text": "No"}
    ],
    "alert": {
        "enabled": true,
        "condition": "Yes",
        "title": "public entities are cool"
    }
}
```

2.2 IMPORT PROCESS
------------------
Location: `loadFormJson()` function, within the dropdown field restoration block
(around line 980-1070 and 1713-1831 - there are two locations for different code paths)

When importing a JSON file, alert data must be restored to `window.triggerDropdownAlert`
and the UI must be updated.

Implementation:

Step 1: Check for Alert Data in Imported JSON
```javascript
// After restoring dropdown options
if (triggerField.alert && triggerField.alert.enabled) {
    // Initialize the data structure
    const alertKey = `${question.questionId}_${fieldOrder}_${sequenceIndex + 1}_${actualFieldCount}`;
    if (!window.triggerDropdownAlert) {
        window.triggerDropdownAlert = {};
    }
    window.triggerDropdownAlert[alertKey] = {
        enabled: true,
        condition: triggerField.alert.condition || '',
        title: triggerField.alert.title || ''
    };
```

Step 2: Wait for Options to be Added
```javascript
    // Wait for options to be added before restoring alert
    setTimeout(() => {
        const enableAlertCheckbox = document.getElementById(`enableAlertDropdown${question.questionId}_${fieldOrder}_${sequenceIndex + 1}_${actualFieldCount}`);
        if (enableAlertCheckbox) {
            enableAlertCheckbox.checked = true;
            // Manually trigger the change event to update the UI
            const event = new Event('change');
            enableAlertCheckbox.dispatchEvent(event);
```

Step 3: Wait for UI to Update, Then Set Values
```javascript
            // Set the alert values after a delay to ensure UI is ready
            setTimeout(() => {
                if (typeof updateTriggerDropdownAlertUI === 'function') {
                    updateTriggerDropdownAlertUI(question.questionId, fieldOrder, sequenceIndex + 1, actualFieldCount);
                    // Set the alert values after UI is updated
                    setTimeout(() => {
                        const alertContainer = document.getElementById(`alertUIDropdown${question.questionId}_${fieldOrder}_${sequenceIndex + 1}_${actualFieldCount}`);
                        if (alertContainer) {
                            const conditionDropdown = alertContainer.querySelector('select');
                            const titleInput = alertContainer.querySelector('input[type="text"]');
                            if (conditionDropdown && triggerField.alert.condition) {
                                conditionDropdown.value = triggerField.alert.condition;
                                conditionDropdown.dispatchEvent(new Event('change'));
                            }
                            if (titleInput && triggerField.alert.title) {
                                titleInput.value = triggerField.alert.title;
                                titleInput.dispatchEvent(new Event('blur'));
                            }
                        }
                    }, 300);
                }
            }, 400);
        }
    }, 200);
}
```

Key Patterns:
- Multiple nested `setTimeout` calls ensure UI elements exist before accessing them
- Manually dispatch events to trigger handlers
- The sequence is: set checkbox -> trigger change -> wait for UI update -> set values
- Total delay chain: 200ms -> 400ms -> 300ms = 900ms total

================================================================================
PART 3: FORM GENERATION (FormWiz GUI/generate.js)
================================================================================

3.1 COLLECTING ALERT DATA DURING FORM GENERATION
-------------------------------------------------
Location: Two places where dropdown fields are collected from GUI:
1. Around line 1885-1950 (first collection point)
2. Around line 3249-3335 (second collection point)

When building `unifiedFieldsMap` from the GUI, alert data must be included.

Implementation:

```javascript
// After collecting dropdown options and conditional logic
const dropdownField = {
    type: 'dropdown',
    fieldName: dropdownFieldNameEl.value.trim(),
    options: dropdownOptions
};

// Check for alert data from window.triggerDropdownAlert
const alertKey = `${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`;
console.log('[ALERT DEBUG] Collecting alert data for key:', alertKey);

if (window.triggerDropdownAlert && window.triggerDropdownAlert[alertKey]) {
    const storedAlert = window.triggerDropdownAlert[alertKey];
    console.log('[ALERT DEBUG] Found stored alert data:', storedAlert);
    
    if (storedAlert.enabled && storedAlert.condition && storedAlert.title) {
        dropdownField.alert = {
            enabled: storedAlert.enabled,
            condition: storedAlert.condition.trim(),
            title: storedAlert.title.trim()
        };
        console.log('[ALERT DEBUG] Added alert to dropdownField:', dropdownField.alert);
        }
}
```

Key Pattern: Alert data is collected from `window.triggerDropdownAlert` using
the same key pattern used throughout the GUI. This data is then included in
the `unifiedFieldsMap` which is embedded in the generated HTML.

3.2 RUNTIME FIELD ENRICHMENT
-----------------------------
Location: `createTriggerFieldsContainer()` function in generated HTML (around line 5684)

Problem: When `createTriggerFieldsContainer` is called at runtime (when user
selects a dropdown option), it receives `fields` parameter that may not include
alert data because it comes from a different source.

Solution: Enrich the fields with data from `unifiedFieldsMap` before processing.

Implementation:

```javascript
// Helper function to enrich triggerField with data from unifiedFieldsMap
function enrichTriggerFieldWithUnifiedData(triggerField, fieldIndex) {
    // Try to find the complete field data from unifiedFieldsMap
    if (window.unifiedFieldsMap && window.unifiedFieldsMap[questionId]) {
        const allFields = window.unifiedFieldsMap[questionId];
        
        // Find the parent dropdown field that contains trigger sequences
        const parentDropdownField = allFields.find(f => 
            f.type === 'dropdown' && 
            f.triggerSequences && 
            Array.isArray(f.triggerSequences) &&
            f.triggerSequences.length > sequenceIndex
        );
        
        if (parentDropdownField) {
            const sequence = parentDropdownField.triggerSequences[sequenceIndex];
            if (sequence && sequence.fields && Array.isArray(sequence.fields)) {
                // Find the matching field by fieldName/label and type, or by index as fallback
                let matchingField = sequence.fields.find(f => 
                    f.type === triggerField.type &&
                    ((f.fieldName && triggerField.fieldName && f.fieldName === triggerField.fieldName) ||
                     (f.label && triggerField.label && f.label === triggerField.label))
                );
                
                // Fallback: try to match by index if name matching failed
                if (!matchingField && fieldIndex < sequence.fields.length) {
                    const fieldByIndex = sequence.fields[fieldIndex];
                    if (fieldByIndex && fieldByIndex.type === triggerField.type) {
                        matchingField = fieldByIndex;
                    }
                }
                
                if (matchingField) {
                    // Merge alert data and other properties from unifiedFieldsMap
                    if (matchingField.alert) {
                        triggerField.alert = matchingField.alert;
                    }
                    // Also merge conditionalLogic if it's missing
                    if (matchingField.conditionalLogic && !triggerField.conditionalLogic) {
                        triggerField.conditionalLogic = matchingField.conditionalLogic;
                    }
                }
            }
        }
    }
    return triggerField;
}

// Call enrichment before processing each field
fields.forEach((triggerField, fieldIndex) => {
    enrichTriggerFieldWithUnifiedData(triggerField, fieldIndex);
    // ... rest of field processing
});
```

Key Patterns:
- Look up data from `window.unifiedFieldsMap` at runtime
- Match fields by both name and type, with index as fallback
- Merge alert data into the triggerField object before use
- This ensures alert data is available even when fields come from different sources

3.3 RUNTIME ALERT FUNCTIONALITY
--------------------------------
Location: `createTriggerFieldsContainer()` function, within dropdown field creation
(around line 6066-6250)

When a dropdown field is created at runtime, alert functionality is added to
the change event handler.

Implementation:

Step 1: Capture Alert Data in Local Variable
```javascript
// Capture alert data in local variable to avoid closure issues
const alertData = triggerField.alert ? {
    enabled: triggerField.alert.enabled || false,
    condition: (triggerField.alert.condition || '').trim(),
    title: (triggerField.alert.title || '').trim()
} : null;
```

Key Pattern: Capture data in a local variable before creating event listeners
to avoid closure issues when iterating through fields.

Step 2: Add Alert Check to Change Handler
```javascript
select.addEventListener('change', function() {
    // Check for alert functionality if enabled
    if (alertData && alertData.enabled && alertData.condition && alertData.title) {
        const selectedValue = (this.value || '').trim();
        const alertCondition = alertData.condition;
                
        if (selectedValue === alertCondition) {
            // Use custom alert modal instead of default browser alert
            if (typeof showAlert === 'function') {
                showAlert(alertData.title);
            } else {
                // Fallback to default alert if showAlert is not available
                alert(alertData.title);
                }
        }
        }
    
    // ... rest of change handler (dropdownMirror, conditional logic, etc.)
});
```

Key Patterns:
- Check if `showAlert` function exists before using custom modal
- Trim values for comparison to avoid whitespace issues
- Alert is shown BEFORE other change handlers run
- Uses `showAlert()` function which displays a custom modal overlay

Custom Alert Modal:
The `showAlert()` function is defined in the generated HTML and displays a
custom modal with:
- Overlay background with blur effect
- Centered popup with rounded corners
- Message displayed in styled div
- "Continue" button to close

================================================================================
PART 4: DATA FLOW SUMMARY
================================================================================

1. USER CONFIGURATION (GUI):
   - User checks "Enable Alert" checkbox
   - Toggle function stores data in `window.triggerDropdownAlert[key]`
   - Update function populates UI and saves condition/title

2. AUTOSAVE:
   - Data is saved to Firebase/localStorage automatically
   - Uses `window.requestAutosave()` function

3. EXPORT (Generate JSON):
   - `download.js` reads from `window.triggerDropdownAlert`
   - Adds `alert: {enabled, condition, title}` to dropdownField
   - Exported in JSON format

4. IMPORT (Load JSON):
   - Reads `alert` property from imported JSON
   - Restores to `window.triggerDropdownAlert`
   - Updates UI checkboxes and inputs
   - Uses nested timeouts to ensure UI is ready

5. FORM GENERATION:
   - `generate.js` collects alert data from `window.triggerDropdownAlert`
   - Includes in `unifiedFieldsMap` which is embedded in HTML

6. RUNTIME (Generated Form):
   - `createTriggerFieldsContainer` enriches fields from `unifiedFieldsMap`
   - Alert data is merged into triggerField object
   - Change event handler checks condition and calls `showAlert()`
   - Custom modal is displayed to user

================================================================================
PART 5: KEY PATTERNS AND CONVENTIONS
================================================================================

5.1 NAMING CONVENTIONS
----------------------
- Checkbox ID: `enableAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Container ID: `alertUIDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Data key: `"{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}"`
- Window object: `window.triggerDropdownAlert`

Pattern to replicate for other field types:
- Replace "Dropdown" with field type (e.g., "Textbox", "Checkbox")
- Keep the rest of the pattern the same

5.2 DATA STRUCTURE
------------------
```javascript
window.triggerDropdownAlert = {
    "1_5_1_4": {  // Key: questionId_fieldCount_sequenceCount_triggerFieldCount
        enabled: true,
        condition: "Yes",  // The option value that triggers the alert
        title: "public entities are cool"  // The alert message
    }
}
```

5.3 TOGGLE FUNCTION PATTERN
----------------------------
1. Get checkbox and container elements
2. Initialize window data structure if needed
3. Show/hide container based on checkbox state
4. Update enabled state in data structure
5. Call update function if enabled, clear data if disabled
6. Trigger autosave

5.4 UPDATE FUNCTION PATTERN
----------------------------
1. Get container element
2. Initialize window data structure
3. Get dynamic options/data from parent field DOM
4. Clear container innerHTML
5. Create UI elements (dropdowns, inputs)
6. Populate with existing values from data structure
7. Add event handlers that update data structure and trigger autosave
8. Append elements to container

5.5 EXPORT PATTERN
------------------
1. Check `window.trigger{FieldType}Alert` for stored data
2. Check checkbox state as fallback
3. Check UI elements as final fallback
4. Add alert property to field object if enabled and has data
5. Include in JSON export

5.6 IMPORT PATTERN
------------------
1. Check for alert property in imported JSON
2. Restore to `window.trigger{FieldType}Alert`
3. Use setTimeout chain to wait for UI elements
4. Check checkbox and trigger change event
5. Call update function to populate UI
6. Set values in UI inputs/dropdowns
7. Dispatch events to trigger handlers

5.7 RUNTIME GENERATION PATTERN
-------------------------------
1. Collect alert data during form generation
2. Include in unifiedFieldsMap (or similar data structure)
3. At runtime, enrich field objects with data from unifiedFieldsMap
4. Capture alert data in local variable before event handlers
5. Check condition in change/input handler
6. Call custom alert function if condition matches

================================================================================
PART 6: REPLICATING FOR OTHER FIELD TYPES
================================================================================

To add alert functionality to textbox fields in trigger sequences:

STEP 1: Add UI Checkbox
-----------------------
In `addTriggerLabel()` or equivalent function, add:
```javascript
<div style="margin-bottom: 8px; text-align: center;">
    <label for="enableAlertLabel{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}">
        Enable Alert
    </label>
    <div style="display: flex; justify-content: center;">
        <input type="checkbox" 
               id="enableAlertLabel{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}"
               onchange="toggleTriggerLabelAlert({questionId}, {fieldCount}, {sequenceCount}, {triggerFieldCount})">
    </div>
    <div id="alertUILabel{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}" 
         style="margin-top: 8px; display: none;">
        <!-- Alert UI will be populated here -->
    </div>
</div>
```

STEP 2: Create Toggle Function
-------------------------------
```javascript
function toggleTriggerLabelAlert(questionId, fieldCount, sequenceCount, triggerFieldCount) {
    const checkbox = document.getElementById(`enableAlertLabel${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
    const container = document.getElementById(`alertUILabel${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
    if (!checkbox || !container) return;

    container.style.display = checkbox.checked ? 'block' : 'none';
    
    if (!window.triggerLabelAlert) {
        window.triggerLabelAlert = {};
    }
    const key = `${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`;
    if (!window.triggerLabelAlert[key]) {
        window.triggerLabelAlert[key] = { enabled: false, condition: '', title: '' };
    }
    
    window.triggerLabelAlert[key].enabled = checkbox.checked;
    
    if (checkbox.checked) {
        updateTriggerLabelAlertUI(questionId, fieldCount, sequenceCount, triggerFieldCount);
    } else {
        window.triggerLabelAlert[key].condition = '';
        window.triggerLabelAlert[key].title = '';
    }
    
    if (typeof window.requestAutosave === 'function') {
        window.requestAutosave();
    }
}
```

STEP 3: Create Update Function
-------------------------------
For textboxes, the "condition" might be:
- An exact text match
- A pattern match
- A length check
- etc.

Adjust the UI accordingly. For exact match, use a text input instead of dropdown:
```javascript
function updateTriggerLabelAlertUI(questionId, fieldCount, sequenceCount, triggerFieldCount) {
    const container = document.getElementById(`alertUILabel${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
    if (!container) return;
    
    if (!window.triggerLabelAlert) {
        window.triggerLabelAlert = {};
    }
    const key = `${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`;
    if (!window.triggerLabelAlert[key]) {
        window.triggerLabelAlert[key] = { enabled: true, condition: '', title: '' };
    }
    
    container.innerHTML = '';
    
    // Condition input (exact text match example)
    const conditionRow = document.createElement('div');
    conditionRow.style.cssText = 'margin-bottom: 8px; display: flex; flex-direction: column; align-items: center; gap: 4px;';
    
    const conditionLabel = document.createElement('label');
    conditionLabel.textContent = 'Alert Condition (exact text):';
    conditionLabel.style.cssText = 'font-weight: bold; color: #333; font-size: 12px;';
    conditionRow.appendChild(conditionLabel);
    
    const conditionInput = document.createElement('input');
    conditionInput.type = 'text';
    conditionInput.placeholder = 'Enter text that triggers alert...';
    conditionInput.style.cssText = 'width: 70%; max-width: 300px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 12px;';
    conditionInput.value = window.triggerLabelAlert[key].condition || '';
    conditionInput.onchange = () => {
        if (!window.triggerLabelAlert[key]) {
            window.triggerLabelAlert[key] = { enabled: true, condition: '', title: '' };
        }
        window.triggerLabelAlert[key].condition = conditionInput.value.trim();
        if (typeof window.requestAutosave === 'function') {
            window.requestAutosave();
        }
    };
    conditionInput.onblur = () => {
        if (!window.triggerLabelAlert[key]) {
            window.triggerLabelAlert[key] = { enabled: true, condition: '', title: '' };
        }
        window.triggerLabelAlert[key].condition = conditionInput.value.trim();
        if (typeof window.requestAutosave === 'function') {
            window.requestAutosave();
        }
    };
    conditionRow.appendChild(conditionInput);
    container.appendChild(conditionRow);
    
    // Title input (same as dropdown version)
    // ... (copy from dropdown implementation)
}
```

STEP 4: Update Export
---------------------
In `download.js`, find where label fields are collected and add:
```javascript
// Check for alert data from window.triggerLabelAlert
const alertKey = `${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`;
if (window.triggerLabelAlert && window.triggerLabelAlert[alertKey]) {
    const storedAlert = window.triggerLabelAlert[alertKey];
    if (storedAlert.enabled && storedAlert.condition && storedAlert.title) {
        labelField.alert = {
            enabled: storedAlert.enabled,
            condition: storedAlert.condition.trim(),
            title: storedAlert.title.trim()
        };
    }
}
```

STEP 5: Update Import
---------------------
In `download.js`, find label field restoration and add alert restoration
(similar to dropdown import, but use "Label" instead of "Dropdown" in IDs).

STEP 6: Update Form Generation
-------------------------------
In `generate.js`, find where label fields are collected and add alert collection
(similar to dropdown collection).

In `createTriggerFieldsContainer`, ensure label fields are enriched with alert
data (already handled by the enrichTriggerFieldWithUnifiedData function).

STEP 7: Add Runtime Alert Check
--------------------------------
In `createTriggerFieldsContainer`, in the label field creation section:
```javascript
// Capture alert data
const alertData = triggerField.alert ? {
    enabled: triggerField.alert.enabled || false,
    condition: (triggerField.alert.condition || '').trim(),
    title: (triggerField.alert.title || '').trim()
} : null;

// Add to input event handler
input.addEventListener('input', function() {
    if (alertData && alertData.enabled && alertData.condition && alertData.title) {
        const inputValue = (this.value || '').trim();
        if (inputValue === alertData.condition) {
            if (typeof showAlert === 'function') {
                showAlert(alertData.title);
        } else {
                alert(alertData.title);
        }
    }
}
});
```

================================================================================
PART 7: COMMON GOTCHAS AND TROUBLESHOOTING
================================================================================

GOTCHA 1: Closure Issues
------------------------
Problem: When iterating through fields with forEach, event handlers may
reference the wrong field data due to closure issues.

Solution: Always capture data in local variables before creating event handlers:
```javascript
const alertData = triggerField.alert ? { ... } : null;
select.addEventListener('change', function() {
    // Use alertData here, not triggerField.alert directly
});
```

GOTCHA 2: Data Not in unifiedFieldsMap
---------------------------------------
Problem: Alert data exists in `window.triggerDropdownAlert` but not in
`unifiedFieldsMap` when form is generated.

Solution: Ensure alert data is collected during form generation (around
lines 1916 and 3280 in generate.js). The enrichTriggerFieldWithUnifiedData
function will then find it at runtime.

GOTCHA 3: UI Not Populated on Import
-------------------------------------
Problem: After importing JSON, alert UI is not shown or values are empty.

Solution: Use nested setTimeout calls to ensure DOM elements exist:
- 200ms: Wait for field to be created
- 400ms: Wait for update function to populate UI
- 300ms: Set values in UI elements

GOTCHA 4: Options Not Available for Condition Dropdown
-------------------------------------------------------
Problem: updateTriggerDropdownAlertUI can't find dropdown options.

Solution: Ensure options are added to the DOM before calling the update
function. The update function reads options from DOM, not from a data structure.

GOTCHA 5: Alert Shows But Uses Default Browser Alert
-----------------------------------------------------
Problem: `showAlert` function not found, falls back to `alert()`.

Solution: Ensure `showAlert` function is defined in generated HTML before
createTriggerFieldsContainer runs. The function should be in the script block
generated by generate.js.

GOTCHA 6: Condition Matching Not Working
-----------------------------------------
Problem: Alert doesn't show even when condition should match.

Solution: Always trim values before comparison:
```javascript
const selectedValue = (this.value || '').trim();
const alertCondition = alertData.condition;
if (selectedValue === alertCondition) { ... }
```

================================================================================
END OF FEATURE #1 DOCUMENTATION
================================================================================

================================================================================
FEATURE #2: ENABLE HARD ALERT FOR TRIGGER DROPDOWN FIELDS
================================================================================

PURPOSE:
--------
Allows form builders to configure "hard alerts" on dropdown fields within
trigger sequences. Hard alerts are similar to regular alerts, but with two
critical differences:
1. They disable the right arrow navigation button when the condition is met
2. They include a subtitle "Please change your answer to proceed" in the alert modal
3. The user cannot proceed to the next question until ALL hard alert conditions are resolved

Example: A dropdown "Are they a public entity?" has options "Yes" and "No".
The form builder can enable a hard alert so that when users select "No", they
see an alert message like "123" with the subtitle, and the right arrow button
becomes disabled (greyed out) until they change their answer.

CONTEXT:
--------
This feature extends the regular alert functionality (Feature #1) with the
ability to block navigation. It's implemented for dropdown fields within trigger
sequences, and is particularly useful for numbered dropdowns where multiple
entries exist (e.g., "How many people are you suing?" creates entries 1, 2, 3...).
The navigation button must remain disabled if ANY entry has an active hard alert.

KEY DIFFERENCES FROM REGULAR ALERTS:
------------------------------------
1. Data storage: Uses `window.triggerDropdownHardAlert` (not `window.triggerDropdownAlert`)
2. Alert display: Calls `showAlert(title, true)` with second parameter `true`
3. Navigation blocking: Requires `checkAllHardAlertsAndUpdateNavigation()` function
4. Button state: `updateButtons()` must check `hardAlertActive` before enabling
5. Multiple entries: Must check ALL entries (1-10) to see if ANY have active hard alerts

================================================================================
PART 1: GUI INTERFACE (FormWiz GUI/gui.js)
================================================================================

1.1 ADDING THE UI CHECKBOX
---------------------------
Location: `addTriggerDropdown()` function (around line 3197, after "Enable Alert" checkbox)

When a dropdown field is added to a trigger sequence, an "Enable Hard Alert" checkbox
is added right after the "Enable Alert" checkbox.

UI Structure:
```html
<div style="margin-bottom: 8px; text-align: center;">
    <label for="enableHardAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}">
        Enable Hard Alert
    </label>
    <div style="display: flex; justify-content: center;">
        <input type="checkbox" 
               id="enableHardAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}"
               onchange="toggleTriggerDropdownHardAlert({questionId}, {fieldCount}, {sequenceCount}, {triggerFieldCount})">
    </div>
    <div id="hardAlertUIDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}" 
         style="margin-top: 8px; display: none;">
        <!-- Hard Alert UI will be populated here -->
    </div>
</div>
```

Key Patterns:
- Checkbox ID pattern: `enableHardAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Container ID pattern: `hardAlertUIDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Container is initially hidden (`display: none`)
- The toggle function is called on checkbox `onchange` event

1.2 TOGGLE FUNCTION
-------------------
Location: `toggleTriggerDropdownHardAlert()` function (around line 4000)

Purpose: Shows/hides the hard alert configuration UI and manages the data structure.

Function Signature:
```javascript
function toggleTriggerDropdownHardAlert(questionId, fieldCount, sequenceCount, triggerFieldCount)
```

Implementation is identical to `toggleTriggerDropdownAlert`, but uses:
- `window.triggerDropdownHardAlert` instead of `window.triggerDropdownAlert`
- `updateTriggerDropdownHardAlertUI` instead of `updateTriggerDropdownAlertUI`
- `enableHardAlertDropdown` and `hardAlertUIDropdown` IDs

1.3 UPDATE UI FUNCTION
----------------------
Location: `updateTriggerDropdownHardAlertUI()` function (around line 4030)

Implementation is identical to `updateTriggerDropdownAlertUI`, but:
- Uses `window.triggerDropdownHardAlert` instead of `window.triggerDropdownAlert`
- Uses `hardAlertUIDropdown` container ID
- Everything else is the same (condition dropdown, title input)

================================================================================
PART 2: EXPORT/IMPORT (FormWiz GUI/download.js)
================================================================================

2.1 EXPORT PROCESS
------------------
Location: Field collection code in `getFormJSON()` function (around line 1916 and 3280)

Export process is identical to regular alerts, but uses `window.triggerDropdownHardAlert`:

```javascript
// Check for hard alert data from window.triggerDropdownHardAlert
const hardAlertKey = `${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`;
if (window.triggerDropdownHardAlert && window.triggerDropdownHardAlert[hardAlertKey]) {
    const storedHardAlert = window.triggerDropdownHardAlert[hardAlertKey];
    if (storedHardAlert.enabled && storedHardAlert.condition && storedHardAlert.title) {
        dropdownField.hardAlert = {
            enabled: storedHardAlert.enabled,
            condition: storedHardAlert.condition.trim(),
            title: storedHardAlert.title.trim()
        };
    }
}
```

JSON Export Format:
```json
{
    "type": "dropdown",
    "fieldName": "Are they a public entity?",
    "options": [
        {"text": "Yes"},
        {"text": "No"}
    ],
    "hardAlert": {
        "enabled": true,
        "condition": "No",
        "title": "123"
    }
}
```

2.2 IMPORT PROCESS
------------------
Location: `loadFormJson()` function, within the dropdown field restoration block

Import process is identical to regular alerts, but uses:
- `window.triggerDropdownHardAlert` instead of `window.triggerDropdownAlert`
- `enableHardAlertDropdown` and `hardAlertUIDropdown` IDs
- `updateTriggerDropdownHardAlertUI` function
- `hardAlert` property instead of `alert` property

================================================================================
PART 3: FORM GENERATION (FormWiz GUI/generate.js)
================================================================================

3.1 COLLECTING HARD ALERT DATA DURING FORM GENERATION
------------------------------------------------------
Location: Two places where dropdown fields are collected from GUI:
1. Around line 1916-1950 (first collection point)
2. Around line 3280-3335 (second collection point)

Implementation is identical to regular alerts, but collects from `window.triggerDropdownHardAlert`:

```javascript
// Check for hard alert data from window.triggerDropdownHardAlert
const hardAlertKey = `${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`;
if (window.triggerDropdownHardAlert && window.triggerDropdownHardAlert[hardAlertKey]) {
    const storedHardAlert = window.triggerDropdownHardAlert[hardAlertKey];
    if (storedHardAlert.enabled && storedHardAlert.condition && storedHardAlert.title) {
        dropdownField.hardAlert = {
            enabled: storedHardAlert.enabled,
            condition: storedHardAlert.condition.trim(),
            title: storedHardAlert.title.trim()
        };
    }
}
```

**For Regular Dropdown Questions (not trigger sequences):**

When collecting hard alert data for regular dropdown questions, store it in `window.hardAlertData`:

```javascript
// Handle Hard Alert - check before generating select
const hardAlertEnabledEl = qBlock.querySelector(`#enableHardAlert${questionId}`);
const hardAlertEnabled = hardAlertEnabledEl && hardAlertEnabledEl.checked;
let hardAlertHandlerCall = '';
if (hardAlertEnabled) {
  const hardAlertTriggerEl = qBlock.querySelector(`#hardAlertTrigger${questionId}`);
  const hardAlertTitleEl = qBlock.querySelector(`#hardAlertTitle${questionId}`);
  const hardAlertTrigger = hardAlertTriggerEl ? hardAlertTriggerEl.value.trim() : "";
  const hardAlertTitle = hardAlertTitleEl ? hardAlertTitleEl.value.trim() : "";
  // Only include handler call if both trigger and title are set
  if (hardAlertTrigger && hardAlertTitle) {
    hardAlertHandlerCall = ` handleHardAlert${questionId}(this.value)`;
    // CRITICAL: Store hard alert data for runtime - MUST include enabled: true
    if (!window.hardAlertData) {
      window.hardAlertData = {};
    }
    window.hardAlertData[questionId] = {
      enabled: true,  // CRITICAL: Must include enabled property
      trigger: hardAlertTrigger,
      title: hardAlertTitle,
      dropdownId: ddNm  // The dropdown element ID
    };
  }
}
```

**CRITICAL: Embedding `window.hardAlertData` in Generated HTML**

The `window.hardAlertData` object MUST be embedded in the generated HTML so it's available
at runtime. Add this line where other global variables are embedded (around line 5372):

```javascript
formHTML += `window.hardAlertData = ${JSON.stringify(window.hardAlertData || {})};\n`;
```

Without this, `checkAllHardAlertsAndUpdateNavigation()` won't be able to find hard alert
data for regular dropdowns, and the navigation button won't be disabled.

3.2 RUNTIME FIELD ENRICHMENT
-----------------------------
Location: `enrichTriggerFieldWithUnifiedData()` function in `createTriggerFieldsContainer()`

The enrichment function must also merge `hardAlert` data:

```javascript
// Merge hardAlert data if present
if (matchingField.hardAlert) {
    triggerField.hardAlert = matchingField.hardAlert;
}
```

3.3 RUNTIME HARD ALERT FUNCTIONALITY
-------------------------------------
Location: `createTriggerFieldsContainer()` function, within dropdown field creation

Step 1: Capture Hard Alert Data
```javascript
// Capture hard alert data in local variable
const hardAlertData = triggerField.hardAlert ? {
    enabled: triggerField.hardAlert.enabled || false,
    condition: (triggerField.hardAlert.condition || '').trim(),
    title: (triggerField.hardAlert.title || '').trim()
} : null;
```

Step 2: Add Hard Alert Check to Change Handler
```javascript
select.addEventListener('change', function() {
    // ... regular alert check ...
    
    // Check for hard alert functionality if enabled
    if (hardAlertData && hardAlertData.enabled && hardAlertData.condition && hardAlertData.title) {
        const selectedValue = (this.value || '').trim();
        const hardAlertCondition = hardAlertData.condition;
        
        if (selectedValue === hardAlertCondition) {
            // Use custom alert modal with hard alert flag (second parameter = true)
            if (typeof showAlert === 'function') {
                showAlert(hardAlertData.title, true); // true = hard alert
        } else {
                alert(hardAlertData.title);
            }
        }
    }
    
    // CRITICAL: Check all hard alerts and update navigation button state
    checkAllHardAlertsAndUpdateNavigation();
    
    // ... rest of change handler ...
});
```

Key Pattern: `checkAllHardAlertsAndUpdateNavigation()` must be called after
checking the individual hard alert, so it can evaluate ALL dropdowns and update
the button state accordingly.

3.4 CUSTOM ALERT MODAL WITH HARD ALERT
---------------------------------------
Location: `showAlert()` function in generated HTML

The `showAlert()` function accepts a second parameter `isHardAlert`:

```javascript
function showAlert(message, isHardAlert) {
    const alertOverlay = document.getElementById('alertOverlay');
    const alertMessage = document.getElementById('alertMessage');
    if (alertOverlay && alertMessage) {
        if (isHardAlert) {
            // For hard alerts, add subtitle
            alertMessage.innerHTML = '<div style="text-align: center;">' +
                '<div style="margin-bottom: 10px;">' + message + '</div>' +
                '<div style="font-size: 0.9em; color: #666; font-style: italic;">Please change your answer to proceed</div>' +
                '</div>';
        } else {
            // Regular alert - just text
            alertMessage.textContent = message;
            }
        alertOverlay.style.display = 'flex';
    }
}
```

3.5 CHECK ALL HARD ALERTS FUNCTION
-----------------------------------
Location: `checkAllHardAlertsAndUpdateNavigation()` function (around line 7578)

Purpose: Checks ALL dropdowns in ALL entries for active hard alerts and updates
the navigation button state accordingly.

CRITICAL IMPLEMENTATION DETAILS:

1. Must check ALL entries (1-10) for numbered dropdowns
2. Must use correct baseNodeId (parent dropdown's fieldName, not questionNameId)
3. Must not use early returns - check all entries even after finding one match
4. Must update button's `hardAlertActive` data attribute
5. **MUST check regular dropdown questions using `window.hardAlertData`**
6. **MUST embed `window.hardAlertData` in generated HTML**
5. **MUST check regular dropdown questions using `window.hardAlertData`**
6. **MUST embed `window.hardAlertData` in generated HTML**

Implementation:

```javascript
function checkAllHardAlertsAndUpdateNavigation() {
    let hasActiveHardAlert = false;

    // Check unifiedFieldsMap for all hard alerts (trigger sequence dropdowns)
    if (window.unifiedFieldsMap) {
        Object.keys(window.unifiedFieldsMap).forEach(questionId => {
            const allFields = window.unifiedFieldsMap[questionId];
            if (!Array.isArray(allFields)) return;

            // Check all dropdown fields in trigger sequences
            allFields.forEach(field => {
                if (field.type === 'dropdown' && field.triggerSequences && Array.isArray(field.triggerSequences)) {
                    field.triggerSequences.forEach((sequence, seqIndex) => {
                        if (sequence.fields && Array.isArray(sequence.fields)) {
                            sequence.fields.forEach(triggerField => {
                                // Check for hard alert
                                if (triggerField.type === 'dropdown' && triggerField.hardAlert && triggerField.hardAlert.enabled) {
                                    const hardAlertCondition = (triggerField.hardAlert.condition || '').trim();
                                    
                                    if (hardAlertCondition) {
                                        // CRITICAL: Use parent dropdown's fieldName (sanitized) as baseNodeId
                                        // For numbered dropdowns, this matches how createTriggerFieldsContainer creates IDs
                                        let baseNodeId = '';
                                        if (field.fieldName) {
                                            baseNodeId = (field.fieldName || '').toLowerCase()
                                                .replace(/[?]/g, '')
                                                .replace(/[^a-z0-9_]+/g, '_')
                                                .replace(/^_+|_+$/g, '');
                                        } else if (field.nodeId) {
                                            baseNodeId = field.nodeId;
                } else {
                                            baseNodeId = (window.questionNameIds && window.questionNameIds[questionId]) || ('answer' + questionId);
                                        }
                                        
                                        // Sanitize trigger field name
                                        const sanitizedFieldName = (triggerField.fieldName || '').toLowerCase()
                                            .replace(/[?]/g, '')
                                            .replace(/[^a-z0-9_]+/g, '_')
                                            .replace(/^_+|_+$/g, '');
                                        
                                        // Check ALL entries (1-10) - don't return early!
                                        for (let entryNum = 1; entryNum <= 10; entryNum++) {
                                            const dropdownId = baseNodeId + '_' + sanitizedFieldName + '_' + entryNum;
                                            const dropdownEl = document.getElementById(dropdownId);
                                            
                                            if (dropdownEl) {
                                                const selectedValue = (dropdownEl.value || '').trim();
                                                if (selectedValue === hardAlertCondition) {
                                                    hasActiveHardAlert = true;
                                                    // Don't return - continue checking all entries
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    });
                }
            });
        });
    }

    // CRITICAL: Check regular dropdown questions for hard alerts
    // This is required for hard alerts on regular dropdown questions (not trigger sequences)
    if (window.hardAlertData) {
        Object.keys(window.hardAlertData).forEach(questionId => {
            const hardAlertInfo = window.hardAlertData[questionId];
            // CRITICAL: Must check for enabled property - it must be included when storing data
            if (hardAlertInfo && hardAlertInfo.enabled && hardAlertInfo.trigger && hardAlertInfo.dropdownId) {
                const dropdownEl = document.getElementById(hardAlertInfo.dropdownId);
                if (dropdownEl) {
                    const selectedValue = (dropdownEl.value || '').trim();
                    if (selectedValue === hardAlertInfo.trigger.trim()) {
                        hasActiveHardAlert = true;
                    }
                }
            }
        });
    }

    // CRITICAL: Check regular dropdown questions for hard alerts
    // This is required for hard alerts on regular dropdown questions (not trigger sequences)
    if (window.hardAlertData) {
        Object.keys(window.hardAlertData).forEach(questionId => {
            const hardAlertInfo = window.hardAlertData[questionId];
            // CRITICAL: Must check for enabled property - it must be included when storing data
            if (hardAlertInfo && hardAlertInfo.enabled && hardAlertInfo.trigger && hardAlertInfo.dropdownId) {
                const dropdownEl = document.getElementById(hardAlertInfo.dropdownId);
                if (dropdownEl) {
                    const selectedValue = (dropdownEl.value || '').trim();
                    if (selectedValue === hardAlertInfo.trigger.trim()) {
                        hasActiveHardAlert = true;
                    }
                }
            }
        });
    }

    // Update navigation button state
    const activeSection = document.querySelector('.section.active');
    if (activeSection) {
        const nextBtn = activeSection.querySelector('.question-next');
        if (nextBtn) {
            const previousState = nextBtn.dataset.hardAlertActive;
            nextBtn.dataset.hardAlertActive = hasActiveHardAlert ? 'true' : 'false';

            if (hasActiveHardAlert) {
                nextBtn.setAttribute('disabled', 'disabled');
                nextBtn.style.opacity = '0.5';
                nextBtn.style.cursor = 'not-allowed';
            } else {
                // Remove hard alert styling if previously disabled
                if (previousState === 'true') {
                    nextBtn.style.opacity = '';
                    nextBtn.style.cursor = '';
                    // Trigger refreshNav to re-evaluate button state normally
                    const sectionId = activeSection.id;
                    if (window.questionNavControllers && typeof window.questionNavControllers[sectionId] === 'function') {
                        window.questionNavControllers[sectionId]();
                    }
                }
            }
        }
    }
}
```

KEY PATTERNS:
- Use `field.fieldName` (sanitized) for baseNodeId, NOT `questionNameIds[questionId]`
- Check ALL entries (1-10) - never return early from the loop
- Set `hardAlertActive` data attribute on button
- Call `refreshNav()` if hard alert was just cleared (to re-evaluate normally)

3.6 UPDATE BUTTONS FUNCTION MODIFICATION
-----------------------------------------
Location: `updateButtons()` function in navigation code (around line 4485)

The `updateButtons()` function must check for hard alerts BEFORE enabling the button:

```javascript
// CRITICAL FIX: Check for hard alerts before enabling the button
// Hard alerts should always prevent navigation, regardless of canAdvance state
const hasHardAlert = nextBtn.dataset.hardAlertActive === 'true';

// Don't enable if there's an active hard alert
if (canAdvance && !hasHardAlert) {
    nextBtn.removeAttribute('disabled');
    // Make sure styling is cleared if not disabled by hard alert
    if (nextBtn.dataset.hardAlertActive !== 'true') {
        nextBtn.style.opacity = '';
        nextBtn.style.cursor = '';
    }
} else {
    if (hasHardAlert) {
        // Keep disabled due to hard alert
    }
    nextBtn.setAttribute('disabled', 'disabled');
}
```

This ensures that even if `refreshNav()` is called and `updateButtons()` runs,
the button won't be enabled if a hard alert is active.

3.7 CALLING CHECK FUNCTION ON DROPDOWN CHANGES
-----------------------------------------------
Location: Dropdown change event handler in `createTriggerFieldsContainer()`

Must call `checkAllHardAlertsAndUpdateNavigation()` whenever a dropdown value changes:

```javascript
select.addEventListener('change', function() {
    // ... hard alert check and showAlert() call ...
    
    // CRITICAL: Check all hard alerts and update navigation button
    checkAllHardAlertsAndUpdateNavigation();
    
    // ... rest of change handler ...
});
```

Also call on initial page load:

```javascript
// In DOMContentLoaded or window.onload
    setTimeout(() => {
    if (typeof checkAllHardAlertsAndUpdateNavigation === 'function') {
        checkAllHardAlertsAndUpdateNavigation();
    }
}, 500);
```

================================================================================
PART 4: DATA FLOW SUMMARY
================================================================================

1. USER CONFIGURATION (GUI):
   - User checks "Enable Hard Alert" checkbox
   - Toggle function stores data in `window.triggerDropdownHardAlert[key]`
   - Update function populates UI and saves condition/title

2. AUTOSAVE:
   - Data is saved to Firebase/localStorage automatically
   - Uses `window.requestAutosave()` function

3. EXPORT (Generate JSON):
   - `download.js` reads from `window.triggerDropdownHardAlert`
   - Adds `hardAlert: {enabled, condition, title}` to dropdownField
   - Exported in JSON format

4. IMPORT (Load JSON):
   - Reads `hardAlert` property from imported JSON
   - Restores to `window.triggerDropdownHardAlert`
   - Updates UI checkboxes and inputs

5. FORM GENERATION:
   - `generate.js` collects hard alert data from `window.triggerDropdownHardAlert`
   - Includes in `unifiedFieldsMap` which is embedded in HTML

6. RUNTIME (Generated Form):
   - `createTriggerFieldsContainer` enriches fields from `unifiedFieldsMap`
   - Hard alert data is merged into triggerField object
   - Change event handler checks condition and calls `showAlert(title, true)`
   - `checkAllHardAlertsAndUpdateNavigation()` is called to check ALL entries
   - Navigation button is disabled if ANY entry has active hard alert
   - `updateButtons()` respects `hardAlertActive` state

================================================================================
PART 5: KEY PATTERNS AND CONVENTIONS
================================================================================

5.1 NAMING CONVENTIONS
----------------------
- Checkbox ID: `enableHardAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Container ID: `hardAlertUIDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Data key: `"{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}"` (same as regular alerts)
- Window object: `window.triggerDropdownHardAlert`

5.2 DATA STRUCTURE
------------------
```javascript
window.triggerDropdownHardAlert = {
    "1_5_1_4": {  // Key: questionId_fieldCount_sequenceCount_triggerFieldCount
        enabled: true,
        condition: "No",  // The option value that triggers the hard alert
        title: "123"  // The alert message
    }
}
```

5.3 CRITICAL IMPLEMENTATION DETAILS
------------------------------------

1. BASE NODE ID FOR NUMBERED DROPDOWNS:
   - MUST use parent dropdown's `fieldName` (sanitized), NOT `questionNameIds[questionId]`
   - Example: `"are_they_a_business_or_public_entity"` not `"how_many_people_are_you_suing"`
   - This matches how `createTriggerFieldsContainer` constructs dropdown IDs

2. CHECK ALL ENTRIES:
   - Must check entries 1-10 for numbered dropdowns
   - Never return early from the check loop
   - Button must stay disabled if ANY entry has active hard alert

3. BUTTON STATE MANAGEMENT:
   - `hardAlertActive` data attribute must be set on button
   - `updateButtons()` must check this before enabling
   - `checkAllHardAlertsAndUpdateNavigation()` must be called on every dropdown change

4. ALERT MODAL:
   - Call `showAlert(title, true)` with `true` as second parameter
   - Modal will automatically add subtitle "Please change your answer to proceed"

================================================================================
PART 6: COMMON GOTCHAS AND TROUBLESHOOTING
================================================================================

GOTCHA 1: Wrong baseNodeId Used
--------------------------------
Problem: Navigation button enables even when hard alert is active.

Solution: Ensure `checkAllHardAlertsAndUpdateNavigation()` uses `field.fieldName`
(sanitized) for baseNodeId, NOT `questionNameIds[questionId]`. The dropdown IDs
are created as `{parentDropdownFieldName}_{triggerFieldName}_{entryNumber}`, not
`{questionNodeId}_{triggerFieldName}_{entryNumber}`.

GOTCHA 2: Button Enables After Changing One Entry
--------------------------------------------------
Problem: With multiple entries, changing one entry to resolve its hard alert
enables the button even if other entries still have active hard alerts.

Solution: Ensure `checkAllHardAlertsAndUpdateNavigation()` checks ALL entries
(1-10) and never returns early from the loop. Set `hasActiveHardAlert = true`
when ANY entry matches, but continue checking all entries.

GOTCHA 3: refreshNav Enables Button
------------------------------------
Problem: After clearing a hard alert, `refreshNav()` is called which enables
the button even though hard alerts might still be active.

Solution: Ensure `updateButtons()` checks `nextBtn.dataset.hardAlertActive === 'true'`
BEFORE enabling the button. The check must happen AFTER `checkAllHardAlertsAndUpdateNavigation()`
runs and updates the data attribute.

GOTCHA 4: Hard Alert Check Not Called on Change
------------------------------------------------
Problem: Navigation button doesn't update when dropdown value changes.

Solution: Ensure `checkAllHardAlertsAndUpdateNavigation()` is called in the
dropdown's `change` event handler, AFTER checking for the individual hard alert.

GOTCHA 5: Hard Alert Not Shown
-------------------------------
Problem: Alert modal shows but doesn't have the subtitle.

Solution: Ensure `showAlert(title, true)` is called with `true` as the second
parameter. Check that `showAlert()` function handles the `isHardAlert` parameter.

GOTCHA 6: Navigation Button Not Disabled for Regular Dropdowns
----------------------------------------------------------------
Problem: Hard alert shows correctly, but the right arrow button is not greyed out
and disabled for regular dropdown questions.

Solution: This is a CRITICAL issue that requires two fixes:

1. **Include `enabled: true` when storing data**: When storing hard alert data in
   `window.hardAlertData`, you MUST include the `enabled: true` property:
```javascript
   window.hardAlertData[questionId] = {
       enabled: true,  // CRITICAL: Must be included
       trigger: hardAlertTrigger,
       title: hardAlertTitle,
       dropdownId: ddNm
   };
   ```

2. **Embed `window.hardAlertData` in generated HTML**: The `window.hardAlertData`
   object must be embedded in the generated HTML so it's available at runtime.
   Add this line where other global variables are embedded:
```javascript
   formHTML += `window.hardAlertData = ${JSON.stringify(window.hardAlertData || {})};\n`;
   ```

Without both of these, `checkAllHardAlertsAndUpdateNavigation()` won't be able to
find the hard alert data, and the button won't be disabled.

================================================================================
END OF FEATURE #2 DOCUMENTATION
================================================================================

================================================================================
FEATURE #3: ENABLE STATUS FOR DROPDOWN QUESTIONS
================================================================================

PURPOSE:
--------
Allows form builders to configure status tracking for dropdown questions. When a
user selects a specific option in the generated form, a status is added to
`window.formStatuses`. If the user changes their selection, the status is removed.
Statuses can be used by other features (like alert logic status requirements) to
check if certain conditions are met.

Example: A dropdown "Hungry?" has options "Yes" and "No". The form builder can
enable status so that when users select "Yes", a status "needs_food" is added.
This status can then be referenced in alert logic conditions to only show alerts
when the status is active.

CONTEXT:
--------
This feature is implemented for dropdown questions (not trigger sequence dropdowns).
It's a simple status tracking system that maintains a global `window.formStatuses`
object where keys are status titles and values are `true` (active) or the status
is removed (inactive).

KEY CONCEPTS:
------------
1. Status Trigger: The dropdown option value that activates the status
2. Status Title: The unique identifier for the status (e.g., "needs_food")
3. Status Lifecycle: Status is added when trigger option is selected, removed when changed
4. Global State: All statuses are stored in `window.formStatuses` object
5. Console Logging: Status changes are logged to console for debugging

================================================================================
PART 1: GUI INTERFACE (FormWiz GUI/gui.js)
================================================================================

1.1 ADDING THE UI CHECKBOX
---------------------------
Location: `addQuestion()` function (around line 805)

When a question is added, an "Enable Status" checkbox is added after the
"Enable Hidden Logic" section.

UI Structure:
```html
<label>Enable Status: </label>
<input type="checkbox" id="enableStatus${currentQuestionId}" onchange="toggleStatus(${currentQuestionId})">
<div id="statusBlock${currentQuestionId}" style="display: none; margin-top: 10px;">
    <label>Status Trigger:</label>
    <select id="statusTrigger${currentQuestionId}">
        <option value="">Select an option...</option>
    </select><br><br>
    <label>Status Title:</label>
    <input type="text" id="statusTitle${currentQuestionId}" placeholder="Enter status title (e.g., needs_food)">
</div><br>
```

Key Patterns:
- Checkbox ID pattern: `enableStatus{questionId}`
- Container ID pattern: `statusBlock{questionId}`
- Trigger dropdown ID: `statusTrigger{questionId}`
- Title input ID: `statusTitle{questionId}`
- Container is initially hidden (`display: none`)

1.2 TOGGLE FUNCTION
-------------------
Location: `toggleStatus()` function (around line 4826)

Purpose: Shows/hides the status configuration UI and manages the data structure.

Function Signature:
```javascript
function toggleStatus(questionId)
```

Implementation Steps:

Step 1: Get DOM Elements
```javascript
const statusEnabled = document.getElementById(`enableStatus${questionId}`).checked;
const statusBlock = document.getElementById(`statusBlock${questionId}`);
if (!statusBlock) return;
```

Step 2: Show/Hide UI
```javascript
statusBlock.style.display = statusEnabled ? 'block' : 'none';
```

Step 3: Initialize Data Structure
```javascript
if (!window.questionStatus) {
    window.questionStatus = {};
}
if (!window.questionStatus[questionId]) {
    window.questionStatus[questionId] = { enabled: false, trigger: '', title: '' };
}
window.questionStatus[questionId].enabled = statusEnabled;
```

Step 4: Populate Trigger Options or Clear Data
```javascript
if (statusEnabled) {
    updateStatusTriggerOptions(questionId);
} else {
    // Clear status data when disabled
    window.questionStatus[questionId].trigger = '';
    window.questionStatus[questionId].title = '';
}
```

Step 5: Trigger Autosave
```javascript
if (typeof window.requestAutosave === 'function') {
    window.requestAutosave();
}
```

Data Storage:
- Stored in: `window.questionStatus[questionId]`
- Structure: `{ enabled: boolean, trigger: string, title: string }`

1.3 UPDATE TRIGGER OPTIONS FUNCTION
------------------------------------
Location: `updateStatusTriggerOptions()` function (around line 4858)

Purpose: Populates the "Status Trigger" dropdown with options from the current
dropdown question. This ensures the trigger dropdown always reflects the current
options of the parent dropdown.

Function Signature:
```javascript
function updateStatusTriggerOptions(questionId)
```

Implementation Steps:

Step 1: Get Trigger Select and Save Current Value
```javascript
const triggerSelect = document.getElementById(`statusTrigger${questionId}`);
if (!triggerSelect) return;

// Save the currently selected value
const currentValue = triggerSelect.value;
```

Step 2: Clear and Repopulate Options
```javascript
// Clear existing options (except the placeholder)
triggerSelect.innerHTML = '<option value="">Select an option...</option>';

// Get all dropdown options for this question
const dropdownOptionsDiv = document.getElementById(`dropdownOptions${questionId}`);
if (dropdownOptionsDiv) {
    const optionInputs = dropdownOptionsDiv.querySelectorAll('input[type="text"]');
    optionInputs.forEach((input) => {
        const optionText = input.value.trim();
        if (optionText) {
            const option = document.createElement('option');
            option.value = optionText;
            option.textContent = optionText;
            if (optionText === currentValue) {
                option.selected = true;
            }
            triggerSelect.appendChild(option);
        }
    });
}
```

Step 3: Add Change Handler
```javascript
triggerSelect.onchange = () => {
    if (!window.questionStatus) {
        window.questionStatus = {};
    }
    if (!window.questionStatus[questionId]) {
        window.questionStatus[questionId] = { enabled: false, trigger: '', title: '' };
    }
    window.questionStatus[questionId].trigger = triggerSelect.value;
    if (typeof window.requestAutosave === 'function') {
        window.requestAutosave();
    }
};
```

Step 4: Add Change Handler for Title Input
```javascript
const titleInput = document.getElementById(`statusTitle${questionId}`);
if (titleInput) {
    titleInput.onchange = () => {
        if (!window.questionStatus) {
            window.questionStatus = {};
        }
        if (!window.questionStatus[questionId]) {
            window.questionStatus[questionId] = { enabled: false, trigger: '', title: '' };
        }
        window.questionStatus[questionId].title = titleInput.value.trim();
        if (typeof window.requestAutosave === 'function') {
            window.requestAutosave();
        }
    };
    titleInput.onblur = () => {
        // Same as onchange - ensures data is saved
        if (!window.questionStatus) {
            window.questionStatus = {};
        }
        if (!window.questionStatus[questionId]) {
            window.questionStatus[questionId] = { enabled: false, trigger: '', title: '' };
        }
        window.questionStatus[questionId].title = titleInput.value.trim();
        if (typeof window.requestAutosave === 'function') {
            window.requestAutosave();
        }
    };
}
```

Key Pattern: The trigger dropdown is populated from the DOM (dropdown options
container), not from a data structure. This means options must exist in the DOM
before calling this function.

1.4 SYNCING WITH DROPDOWN OPTIONS
----------------------------------
Location: `addDropdownOption()` and `removeDropdownOption()` functions

When dropdown options are added or removed, the status trigger dropdown must be
updated to reflect the changes.

Implementation:
```javascript
// In addDropdownOption() function
function addDropdownOption(questionId, fieldCount) {
    // ... add option to dropdown ...
    
    // Update status trigger options if status is enabled
    const statusCheckbox = document.getElementById(`enableStatus${questionId}`);
    if (statusCheckbox && statusCheckbox.checked) {
        updateStatusTriggerOptions(questionId);
    }
}

// In removeDropdownOption() function
function removeDropdownOption(questionId, fieldCount, optionCount) {
    // ... remove option from dropdown ...
    
    // Update status trigger options if status is enabled
    const statusCheckbox = document.getElementById(`enableStatus${questionId}`);
    if (statusCheckbox && statusCheckbox.checked) {
        updateStatusTriggerOptions(questionId);
    }
}
```

This ensures the status trigger dropdown always matches the current dropdown options.

================================================================================
PART 2: EXPORT/IMPORT (FormWiz GUI/download.js)
================================================================================

2.1 EXPORT PROCESS
------------------
Location: Question data collection in `getFormJSON()` function (around line 3095)

When collecting question data for JSON export, status data must be read from
`window.questionStatus` and added to the question object.

Implementation:

```javascript
// Collect Status data
const statusEnabled = questionBlock.querySelector(`#enableStatus${questionId}`)?.checked || false;
const statusTrigger = questionBlock.querySelector(`#statusTrigger${questionId}`)?.value || "";
const statusTitle = questionBlock.querySelector(`#statusTitle${questionId}`)?.value || "";

// Also check window.questionStatus as fallback
let storedStatusData = null;
if (window.questionStatus && window.questionStatus[questionId]) {
    storedStatusData = window.questionStatus[questionId];
    }

// Use stored data if available, otherwise use UI values
const finalStatusEnabled = storedStatusData ? storedStatusData.enabled : statusEnabled;
const finalStatusTrigger = storedStatusData ? storedStatusData.trigger : statusTrigger;
const finalStatusTitle = storedStatusData ? storedStatusData.title : statusTitle;

// Add to question object
questionData.status = {
    enabled: finalStatusEnabled,
    trigger: finalStatusTrigger,
    title: finalStatusTitle
};
```

JSON Export Format:
```json
{
    "questionId": 1,
    "text": "Hungry?",
    "type": "dropdown",
    "status": {
        "enabled": true,
        "trigger": "Yes",
        "title": "needs_food"
    },
    "options": ["Yes", "No"]
}
```

2.2 IMPORT PROCESS
------------------
Location: `loadFormJson()` function, within question restoration block (around line 514)

When importing a JSON file, status data must be restored to `window.questionStatus`
and the UI must be updated.

Implementation:

```javascript
// Restore Status
if (question.status && question.status.enabled) {
    const statusCheckbox = questionBlock.querySelector(`#enableStatus${question.questionId}`);
    const statusTriggerSelect = questionBlock.querySelector(`#statusTrigger${question.questionId}`);
    const statusTitleInput = questionBlock.querySelector(`#statusTitle${question.questionId}`);
    
    if (statusCheckbox) {
        statusCheckbox.checked = true;
        toggleStatus(question.questionId); // This populates the trigger dropdown with options from DOM
        
        // Set the trigger value after the dropdown is populated
setTimeout(() => {
            if (statusTriggerSelect && question.status.trigger) {
                statusTriggerSelect.value = question.status.trigger;
                statusTriggerSelect.dispatchEvent(new Event('change'));
            }
            if (statusTitleInput && question.status.title) {
                statusTitleInput.value = question.status.title;
                statusTitleInput.dispatchEvent(new Event('blur'));
            }
        }, 100);
    }
    
    // Also restore to window.questionStatus
    if (!window.questionStatus) {
        window.questionStatus = {};
    }
    window.questionStatus[question.questionId] = {
        enabled: true,
        trigger: question.status.trigger || '',
        title: question.status.title || ''
    };
}
```

Key Patterns:
- Must call `toggleStatus()` to populate the trigger dropdown
- Use `setTimeout` to ensure dropdown is populated before setting value
- Dispatch events to trigger handlers
- Restore to both UI and `window.questionStatus`

================================================================================
PART 3: FORM GENERATION (FormWiz GUI/generate.js)
================================================================================

3.1 COLLECTING STATUS DATA DURING FORM GENERATION
-------------------------------------------------
Location: Question processing loop in `getFormHTML()` function (around line 1200-1300)

When building the form HTML, status data must be collected and embedded in the
generated HTML for runtime use.

Implementation:

```javascript
// Check if Status is enabled
const statusCheckbox = qBlock.querySelector("#enableStatus" + questionId);
const statusEnabled = statusCheckbox && statusCheckbox.checked;

let statusTrigger = '';
let statusTitle = '';

if (statusEnabled) {
    // Get from window.questionStatus first (preferred)
    if (window.questionStatus && window.questionStatus[questionId]) {
        statusTrigger = window.questionStatus[questionId].trigger || '';
        statusTitle = window.questionStatus[questionId].title || '';
    } else {
        // Fallback to UI elements
        const statusTriggerEl = qBlock.querySelector("#statusTrigger" + questionId);
        const statusTitleEl = qBlock.querySelector("#statusTitle" + questionId);
        statusTrigger = statusTriggerEl ? statusTriggerEl.value.trim() : '';
        statusTitle = statusTitleEl ? statusTitleEl.value.trim() : '';
    }
}

// Store for runtime
if (!window.statusData) {
    window.statusData = {};
}
window.statusData[questionId] = {
    enabled: statusEnabled,
    trigger: statusTrigger,
    title: statusTitle
};
```

3.2 ADDING STATUS HANDLER TO DROPDOWN
--------------------------------------
Location: Dropdown generation in `getFormHTML()` function (around line 1246)

When a dropdown is generated, if status is enabled, a status handler function
call must be added to the dropdown's `onchange` attribute.

Implementation:

```javascript
// Build onchange attribute
let onchangeAttr = 'dropdownMirror(this, \'' + questionNameId + '\'); updateHiddenLogic(\'' + questionNameId + '\', this.value); updateLinkedFields(); clearInactiveLinkedFields();';

// Add status handler if enabled
if (statusEnabled && statusTrigger && statusTitle) {
    statusHandlerCall = ` handleStatus${questionId}(this.value)`;
    onchangeAttr += statusHandlerCall;
}

// Add to select element
select.setAttribute('onchange', onchangeAttr);
```

3.3 GENERATING STATUS HANDLER FUNCTION
---------------------------------------
Location: Status handler generation in `getFormHTML()` function (around line 1540)

A handler function is generated for each question with status enabled. This function
manages the `window.formStatuses` object.

Implementation:

```javascript
if (statusEnabled && statusTrigger && statusTitle) {
    formHTML += `
        function handleStatus${questionId}(value) {
            // Initialize status object if it doesn't exist
            if (!window.formStatuses) {
                window.formStatuses = {};
            }
            
            const selectedValue = (value || '').trim();
            const statusTrigger = '${statusTrigger}';
            const statusTitle = '${statusTitle}';
            
            // Check if selected value matches the trigger
            if (selectedValue === statusTrigger) {
                // Add status if it doesn't exist
                if (!window.formStatuses[statusTitle]) {
                    window.formStatuses[statusTitle] = true;
                    console.log('[STATUS] Status added:', statusTitle);
                    console.log('[STATUS] Current statuses:', window.formStatuses);
                } else {
                    console.log('[STATUS] Status already exists:', statusTitle);
                }
            } else {
                // Remove status if it exists
                if (window.formStatuses[statusTitle]) {
                    delete window.formStatuses[statusTitle];
                    console.log('[STATUS] Status removed:', statusTitle);
                    console.log('[STATUS] Current statuses:', window.formStatuses);
                }
            }
        }
    `;
}
```

Key Patterns:
- Function name: `handleStatus{questionId}`
- Compares selected value to trigger (exact match, trimmed)
- Adds status to `window.formStatuses[statusTitle] = true` when trigger matches
- Removes status (deletes key) when trigger doesn't match
- Console logs for debugging

================================================================================
PART 4: RUNTIME BEHAVIOR (Generated Form)
================================================================================

4.1 STATUS ACTIVATION
---------------------
When a user selects the trigger option in the dropdown:
1. The dropdown's `onchange` event fires
2. `handleStatus{questionId}(this.value)` is called
3. Function compares value to trigger
4. If match: `window.formStatuses[statusTitle] = true`
5. Console log confirms status addition

4.2 STATUS DEACTIVATION
-----------------------
When a user changes the dropdown to a different option:
1. The dropdown's `onchange` event fires
2. `handleStatus{questionId}(this.value)` is called
3. Function compares value to trigger
4. If no match: `delete window.formStatuses[statusTitle]`
5. Console log confirms status removal

4.3 STATUS USAGE IN OTHER FEATURES
-----------------------------------
Statuses can be checked by other features:

Example - Alert Logic Status Requirements:
```javascript
// In checkAlertLogic() function
if (condition.statusRequirements && condition.statusRequirements.length > 0) {
    let allStatusRequirementsMet = true;
    for (const statusReq of condition.statusRequirements) {
        if (!window.formStatuses || !window.formStatuses[statusReq]) {
            allStatusRequirementsMet = false;
            break;
        }
    }
    if (!allStatusRequirementsMet) {
        continue; // Skip this condition
    }
}
```

4.4 STATUS OBJECT STRUCTURE
----------------------------
```javascript
window.formStatuses = {
    "needs_food": true,
    "needs_water": true,
    "needs_shelter": true
}
```

- Keys are status titles (e.g., "needs_food")
- Values are `true` (status is active)
- If a key doesn't exist, the status is inactive
- Statuses are global across the entire form

================================================================================
PART 5: DATA FLOW SUMMARY
================================================================================

1. USER CONFIGURATION (GUI):
   - User checks "Enable Status" checkbox
   - Toggle function stores data in `window.questionStatus[questionId]`
   - Update function populates trigger dropdown with current options
   - User selects trigger option and enters status title
   - Data is saved to `window.questionStatus`

2. AUTOSAVE:
   - Data is saved to Firebase/localStorage automatically
   - Uses `window.requestAutosave()` function

3. EXPORT (Generate JSON):
   - `download.js` reads from `window.questionStatus` (with UI fallback)
   - Adds `status: {enabled, trigger, title}` to question object
   - Exported in JSON format

4. IMPORT (Load JSON):
   - Reads `status` property from imported JSON
   - Restores to `window.questionStatus`
   - Updates UI checkboxes and inputs
   - Calls `toggleStatus()` to populate trigger dropdown
   - Uses setTimeout to set values after dropdown is populated

5. FORM GENERATION:
   - `generate.js` collects status data from `window.questionStatus` (with UI fallback)
   - Stores in `window.statusData` for runtime
   - Generates `handleStatus{questionId}()` function
   - Adds function call to dropdown's `onchange` attribute

6. RUNTIME (Generated Form):
   - User selects dropdown option
   - `handleStatus{questionId}()` is called
   - Function checks if value matches trigger
   - Adds/removes status from `window.formStatuses`
   - Other features can check `window.formStatuses` for status requirements

================================================================================
PART 6: KEY PATTERNS AND CONVENTIONS
================================================================================

6.1 NAMING CONVENTIONS
----------------------
- Checkbox ID: `enableStatus{questionId}`
- Container ID: `statusBlock{questionId}`
- Trigger dropdown ID: `statusTrigger{questionId}`
- Title input ID: `statusTitle{questionId}`
- Handler function: `handleStatus{questionId}(value)`
- Window object: `window.questionStatus` (GUI) and `window.formStatuses` (runtime)

6.2 DATA STRUCTURE
------------------
GUI Storage:
```javascript
window.questionStatus = {
    "1": {  // Key: questionId
        enabled: true,
        trigger: "Yes",  // The option value that activates the status
        title: "needs_food"  // The status identifier
    }
}
```

Runtime Storage:
```javascript
window.formStatuses = {
    "needs_food": true,  // Key: status title, Value: true (active)
    "needs_water": true
}
```

6.3 TOGGLE FUNCTION PATTERN
---------------------------
1. Get checkbox and container elements
2. Show/hide container based on checkbox state
3. Initialize `window.questionStatus` if needed
4. Update enabled state in data structure
5. Call `updateStatusTriggerOptions()` if enabled, clear data if disabled
6. Trigger autosave

6.4 UPDATE FUNCTION PATTERN
---------------------------
1. Get trigger select element
2. Save current value
3. Clear and repopulate from DOM (dropdown options container)
4. Restore saved value if it still exists
5. Add change handlers to save data and trigger autosave

6.5 EXPORT PATTERN
------------------
1. Check `window.questionStatus` for stored data (preferred)
2. Check UI elements as fallback
3. Add `status: {enabled, trigger, title}` to question object
4. Include in JSON export

6.6 IMPORT PATTERN
------------------
1. Check for `status` property in imported JSON
2. Restore to `window.questionStatus`
3. Check checkbox and call `toggleStatus()` to populate UI
4. Use setTimeout to set values after dropdown is populated
5. Dispatch events to trigger handlers

6.7 RUNTIME GENERATION PATTERN
-------------------------------
1. Collect status data during form generation
2. Store in `window.statusData` for reference
3. Generate `handleStatus{questionId}()` function
4. Add function call to dropdown's `onchange` attribute
5. Function manages `window.formStatuses` at runtime

================================================================================
PART 7: COMMON GOTCHAS AND TROUBLESHOOTING
================================================================================

GOTCHA 1: Trigger Dropdown Not Populated
-----------------------------------------
Problem: Status trigger dropdown is empty when enabling status.

Solution: Ensure `updateStatusTriggerOptions()` is called after enabling status.
The function reads options from the DOM (`#dropdownOptions{questionId}`), so options
must exist in the DOM first. Also ensure `addDropdownOption()` and `removeDropdownOption()`
call `updateStatusTriggerOptions()` to keep it in sync.

GOTCHA 2: Status Not Added at Runtime
--------------------------------------
Problem: Status handler function is not called when dropdown value changes.

Solution: Ensure the status handler call is added to the dropdown's `onchange`
attribute during form generation. Check that `statusHandlerCall` is appended to
the `onchangeAttr` string before setting it on the select element.

GOTCHA 3: Status Not Removed When Changed
------------------------------------------
Problem: Status remains active even after changing dropdown to a different option.

Solution: Ensure the status handler function checks for both match (add) and
non-match (remove) cases. The function should delete the status when the value
doesn't match the trigger.

GOTCHA 4: Status Requirements Not Working
------------------------------------------
Problem: Alert logic status requirements don't work even though status is active.

Solution: Ensure status requirements check `window.formStatuses[statusTitle]`
exists (not just truthy). The check should be:
```javascript
if (!window.formStatuses || !window.formStatuses[statusReq]) {
    // Status requirement not met
}
```

GOTCHA 5: Import Not Restoring Status
--------------------------------------
Problem: After importing JSON, status UI is not shown or values are empty.

Solution: Ensure `toggleStatus()` is called to populate the trigger dropdown
before setting values. Use setTimeout to ensure dropdown is populated:
```javascript
setTimeout(() => {
    if (statusTriggerSelect && question.status.trigger) {
        statusTriggerSelect.value = question.status.trigger;
    }
}, 100);
```

GOTCHA 6: Multiple Statuses with Same Title
--------------------------------------------
Problem: Multiple questions use the same status title, causing conflicts.

Solution: Status titles should be unique across the form. If two questions use
the same title, they will share the same status. Consider using descriptive,
unique titles like "question1_needs_food" vs "question2_needs_food" if needed.

================================================================================
PART 8: REPLICATING FOR OTHER QUESTION TYPES
================================================================================

To add status functionality to checkbox questions:

STEP 1: Add UI Checkbox
-----------------------
In `addQuestion()`, add status checkbox (same as dropdown).

STEP 2: Create Toggle Function
-------------------------------
Same as dropdown, but may need different trigger options (e.g., "checked" vs "unchecked").

STEP 3: Update Form Generation
-------------------------------
Generate handler function that checks checkbox state:
```javascript
function handleStatus${questionId}(checked) {
    if (!window.formStatuses) {
        window.formStatuses = {};
    }
    
    const statusTrigger = '${statusTrigger}'; // e.g., "checked" or "unchecked"
    const statusTitle = '${statusTitle}';
    
    if ((checked && statusTrigger === 'checked') || (!checked && statusTrigger === 'unchecked')) {
        window.formStatuses[statusTitle] = true;
    } else {
        delete window.formStatuses[statusTitle];
    }
}
```

STEP 4: Add Handler to Checkbox
--------------------------------
```javascript
checkbox.addEventListener('change', function() {
    handleStatus${questionId}(this.checked);
});
```

================================================================================
END OF FEATURE #3 DOCUMENTATION
================================================================================

================================================================================
FEATURE #4: LATEX PREVIEW PDF WITH CART INTEGRATION
================================================================================

PURPOSE:
--------
Allows form builders to configure LaTeX preview PDFs for dropdown questions. When
a user selects a specific option in the generated form, a PDF is generated from
LaTeX code and displayed in a preview. If "Attach to packet" is selected, the PDF
is added to the cart and saved to the user's documents after payment.

Example: A dropdown "Have you sent a demand letter to the defendant?" has options
"Yes" and "No". The form builder can enable LaTeX preview so that when users select
"No", a PDF is generated from LaTeX code (e.g., a demand letter template) and shown
in a preview. If configured to "Attach to packet", the PDF is added to the cart with
a custom filename (e.g., "Demand Letter") and saved to the user's documents after
successful payment.

CONTEXT:
--------
This feature is implemented for dropdown questions. It generates PDFs client-side
using a server endpoint (`/latex_to_pdf`), stores them as Blob objects, and handles
cart integration with proper serialization (base64 encoding) for persistence.

KEY CONCEPTS:
------------
1. LaTeX Preview: Client-side PDF generation from LaTeX code with placeholder replacement
2. Preview Filename: Custom name for the cart entry (separate from preview title)
3. Cart Integration: PDFs are added to cart and saved to documents after payment
4. Blob Serialization: PDFs are converted to base64 for JSON serialization
5. Form Data Replacement: LaTeX placeholders like [user_fullname] are replaced with form values

================================================================================
PART 1: GUI INTERFACE (FormWiz GUI/gui.js)
================================================================================

1.1 ADDING THE UI CHECKBOX
---------------------------
Location: `addQuestion()` function (around line 671)

When a question is added, an "Enable Latex Preview" checkbox is added after the
"Enable PDF Preview" section.

UI Structure:
```html
<label>Enable Latex Preview: </label>
<input type="checkbox" id="enableLatexPreview${currentQuestionId}" onchange="toggleLatexPreview(${currentQuestionId})">
<div id="latexPreviewBlock${currentQuestionId}" style="display: none; margin-top: 10px;">
    <label>Latex Preview Trigger:</label>
    <select id="latexPreviewTrigger${currentQuestionId}">
        <option value="">Select an option...</option>
    </select><br><br>
    <label>Latex Preview Title:</label>
    <input type="text" id="latexPreviewTitle${currentQuestionId}" placeholder="Enter LaTeX preview title"><br><br>
    <label>Preview Filename (for cart):</label>
    <input type="text" id="latexPreviewFilename${currentQuestionId}" placeholder="Enter filename for cart entry"><br><br>
    <label>Latex Content:</label>
    <textarea id="latexPreviewContent${currentQuestionId}" placeholder="Paste LaTeX code here" rows="8" style="width: 100%; font-family: monospace;"></textarea><br><br>
    <label>Latex Price ID:</label>
    <input type="text" id="latexPreviewPriceId${currentQuestionId}" placeholder="Enter Stripe price ID (e.g., price_1..."><br><br>
    <label>Latex Attachment:</label>
    <select id="latexPreviewAttachment${currentQuestionId}">
        <option value="Preview Only">Preview Only</option>
        <option value="Attach to packet">Attach to packet</option>
    </select><br><br>
</div><br>
```

Key Patterns:
- Checkbox ID pattern: `enableLatexPreview{questionId}`
- Container ID pattern: `latexPreviewBlock{questionId}`
- Trigger dropdown ID: `latexPreviewTrigger{questionId}`
- Title input ID: `latexPreviewTitle{questionId}`
- Filename input ID: `latexPreviewFilename{questionId}` (NEW - for cart entry name)
- Content textarea ID: `latexPreviewContent{questionId}`
- Price ID input ID: `latexPreviewPriceId{questionId}`
- Attachment dropdown ID: `latexPreviewAttachment{questionId}`
- Container is initially hidden (`display: none`)

1.2 TOGGLE FUNCTION
-------------------
Location: `toggleLatexPreview()` function (around line 4835)

Purpose: Shows/hides the LaTeX preview configuration UI and populates trigger options.

Function Signature:
```javascript
function toggleLatexPreview(questionId)
```

Implementation Steps:

Step 1: Get DOM Elements
```javascript
const latexPreviewEnabled = document.getElementById(`enableLatexPreview${questionId}`).checked;
const latexPreviewBlock = document.getElementById(`latexPreviewBlock${questionId}`);
latexPreviewBlock.style.display = latexPreviewEnabled ? 'block' : 'none';
```

Step 2: Populate Trigger Options if Enabled
```javascript
if (latexPreviewEnabled) {
    updateLatexPreviewTriggerOptions(questionId);
}
```

1.3 UPDATE TRIGGER OPTIONS FUNCTION
------------------------------------
Location: `updateLatexPreviewTriggerOptions()` function (around line 5047)

Purpose: Populates the "Latex Preview Trigger" dropdown with options from the current
dropdown question.

Implementation is similar to `updateStatusTriggerOptions()`:
- Reads options from `#dropdownOptions{questionId}` container
- Populates the trigger dropdown
- Preserves currently selected value

================================================================================
PART 2: EXPORT/IMPORT (FormWiz GUI/download.js)
================================================================================

2.1 EXPORT PROCESS
------------------
Location: Question data collection in `getFormJSON()` function (around line 3320)

When collecting question data for JSON export, LaTeX preview data is read from
UI elements and added to the question object.

Implementation:

```javascript
latexPreview: {
    enabled: questionBlock.querySelector(`#enableLatexPreview${questionId}`)?.checked || false,
    trigger: questionBlock.querySelector(`#latexPreviewTrigger${questionId}`)?.value || "",
    title: questionBlock.querySelector(`#latexPreviewTitle${questionId}`)?.value || "",
    filename: questionBlock.querySelector(`#latexPreviewFilename${questionId}`)?.value || "",
    content: questionBlock.querySelector(`#latexPreviewContent${questionId}`)?.value || "",
    priceId: questionBlock.querySelector(`#latexPreviewPriceId${questionId}`)?.value || "",
    attachment: questionBlock.querySelector(`#latexPreviewAttachment${questionId}`)?.value || "Preview Only"
}
```

JSON Export Format:
```json
{
    "questionId": 1,
    "text": "Have you sent a demand letter to the defendant?",
    "type": "dropdown",
    "latexPreview": {
        "enabled": true,
        "trigger": "No",
        "title": "Latex PDF Preview",
        "filename": "Demand Letter",
        "content": "\\documentclass{article}\n\\begin{document}\n...",
        "priceId": "price_1SqS2XFJeSRMFQ8XXlBzhcqW",
        "attachment": "Attach to packet"
    },
    "options": ["Yes", "No"]
}
```

2.2 IMPORT PROCESS
------------------
Location: `loadFormJson()` function, within question restoration block (around line 482)

When importing a JSON file, LaTeX preview data must be restored to UI elements.

Implementation:

```javascript
// Restore LaTeX preview if present (AFTER options are added to DOM)
if (question.latexPreview && question.latexPreview.enabled) {
    const latexPreviewCheckbox = questionBlock.querySelector(`#enableLatexPreview${question.questionId}`);
    const latexPreviewTriggerSelect = questionBlock.querySelector(`#latexPreviewTrigger${question.questionId}`);
    const latexPreviewTitleInput = questionBlock.querySelector(`#latexPreviewTitle${question.questionId}`);
    const latexPreviewFilenameInput = questionBlock.querySelector(`#latexPreviewFilename${question.questionId}`);
    const latexPreviewContentInput = questionBlock.querySelector(`#latexPreviewContent${question.questionId}`);
    const latexPreviewPriceIdInput = questionBlock.querySelector(`#latexPreviewPriceId${question.questionId}`);
    const latexPreviewAttachmentSelect = questionBlock.querySelector(`#latexPreviewAttachment${question.questionId}`);
    
    if (latexPreviewCheckbox) {
        latexPreviewCheckbox.checked = true;
        toggleLatexPreview(question.questionId); // This populates the trigger dropdown
        
        // Set values after dropdown is populated
        if (latexPreviewTriggerSelect && question.latexPreview.trigger) {
            latexPreviewTriggerSelect.value = question.latexPreview.trigger;
        }
        if (latexPreviewTitleInput && question.latexPreview.title) {
            latexPreviewTitleInput.value = question.latexPreview.title;
        }
        if (latexPreviewFilenameInput && question.latexPreview.filename) {
            latexPreviewFilenameInput.value = question.latexPreview.filename;
        }
        if (latexPreviewContentInput && question.latexPreview.content) {
            latexPreviewContentInput.value = question.latexPreview.content;
        }
        if (latexPreviewPriceIdInput && question.latexPreview.priceId) {
            latexPreviewPriceIdInput.value = question.latexPreview.priceId;
        }
        if (latexPreviewAttachmentSelect && question.latexPreview.attachment) {
            latexPreviewAttachmentSelect.value = question.latexPreview.attachment;
        }
    }
}
```

Key Patterns:
- Must call `toggleLatexPreview()` to populate the trigger dropdown
- Set values after the dropdown is populated
- All fields are restored: title, filename, content, priceId, attachment

================================================================================
PART 3: FORM GENERATION (FormWiz GUI/generate.js)
================================================================================

3.1 COLLECTING LATEX PREVIEW DATA DURING FORM GENERATION
---------------------------------------------------------
Location: Question processing loop in `getFormHTML()` function (around line 1453)

When building the form HTML, LaTeX preview data must be collected and used to generate
the preview handler function.

Implementation:

```javascript
// Handle LaTeX Preview
if (latexPreviewEnabled) {
    const latexPreviewTriggerEl = qBlock.querySelector(`#latexPreviewTrigger${questionId}`);
    const latexPreviewTitleEl = qBlock.querySelector(`#latexPreviewTitle${questionId}`);
    const latexPreviewFilenameEl = qBlock.querySelector(`#latexPreviewFilename${questionId}`);
    const latexPreviewContentEl = qBlock.querySelector(`#latexPreviewContent${questionId}`);
    const latexPreviewPriceIdEl = qBlock.querySelector(`#latexPreviewPriceId${questionId}`);
    const latexPreviewAttachmentEl = qBlock.querySelector(`#latexPreviewAttachment${questionId}`);
    
    const latexPreviewTrigger = latexPreviewTriggerEl ? latexPreviewTriggerEl.value : "";
    const latexPreviewTitle = latexPreviewTitleEl ? latexPreviewTitleEl.value : "LaTeX Preview";
    const latexPreviewFilenameRaw = latexPreviewFilenameEl ? latexPreviewFilenameEl.value : "";
    const latexPreviewFilename = (latexPreviewFilenameRaw && latexPreviewFilenameRaw.trim() !== '') 
        ? latexPreviewFilenameRaw.trim() 
        : latexPreviewTitle;
    const latexPreviewContent = latexPreviewContentEl ? latexPreviewContentEl.value : "";
    const latexPreviewPriceId = latexPreviewPriceIdEl ? latexPreviewPriceIdEl.value : "";
    const latexPreviewAttachment = latexPreviewAttachmentEl ? latexPreviewAttachmentEl.value : "Preview Only";
    
    // Store metadata if "Attach to packet" is selected
    if (latexPreviewTrigger && latexPreviewContent && latexPreviewAttachment === "Attach to packet") {
        // Check if an entry already exists for this questionId and remove it to avoid duplicates
        const existingIndex = latexPreviewQuestions.findIndex(q => q.questionId === questionId);
        if (existingIndex !== -1) {
            latexPreviewQuestions.splice(existingIndex, 1);
        }
        latexPreviewQuestions.push({
            questionId: questionId,
            title: latexPreviewTitle,
            filename: latexPreviewFilename,
            priceId: latexPreviewPriceId,
            trigger: latexPreviewTrigger
        });
    }
}
```

Key Patterns:
- Filename defaults to title if not provided
- Metadata is only stored if "Attach to packet" is selected
- Duplicate entries for the same questionId are prevented

3.2 GENERATING PREVIEW HANDLER FUNCTION
----------------------------------------
Location: LaTeX preview handler generation in `getFormHTML()` function (around line 1495)

A handler function is generated for each question with LaTeX preview enabled. This function
handles PDF generation and preview display.

Implementation:

```javascript
if (latexPreviewTrigger && latexPreviewContent) {
    // Escape LaTeX content for JavaScript string
    const escapedLatexContent = latexPreviewContent
        .replace(/\\/g, '\\\\')
        .replace(/'/g, "\\'")
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r');
    
    formHTML += `
        <div id="latexPreview${questionId}" style="display: none; ...">
            <h4>${latexPreviewTitle}</h4>
            <div id="latexPreviewLoading${questionId}">Generating PDF from LaTeX...</div>
            <iframe id="latexPreviewIframe${questionId}" width="100%" height="600px"></iframe>
        </div>
        <script>
            async function handleLatexPreview${questionId}(value) {
                const previewDiv = document.getElementById('latexPreview${questionId}');
                const iframe = document.getElementById('latexPreviewIframe${questionId}');
                const loadingDiv = document.getElementById('latexPreviewLoading${questionId}');
                const latexContent = \`${escapedLatexContent}\`;
                
                if (value === '${latexPreviewTrigger}') {
                    previewDiv.style.display = 'block';
                    loadingDiv.style.display = 'block';
                    iframe.style.display = 'none';
                    
                    try {
                        // Collect form data for placeholder replacement
                        const form = document.getElementById('customForm');
                        const fd = new FormData();
                        fd.append('latex', latexContent);
                        
                        // Collect all form elements
                        const formElements = form.querySelectorAll('input, textarea, select');
                        const externalFormElements = document.querySelectorAll('input[form="customForm"], textarea[form="customForm"], select[form="customForm"]');
                        const allFormElements = [...formElements, ...externalFormElements];
                        
                        // Add form data to FormData
                        allFormElements.forEach(element => {
                            if (element.name && !element.disabled) {
                                if (element.type === 'checkbox' || element.type === 'radio') {
                                    if (element.checked) {
                                        fd.append(element.name, 'on');
                                    }
                                } else {
                                    let value = element.value;
                                    if (element.type === 'date' && value) {
                                        value = formatDateForServer(value);
                                    }
                                    if (value && value.trim() !== '') {
                                        fd.append(element.name, value);
                                    }
                                }
                            }
                        });
                        
                        // Send to server to generate PDF
                        const res = await fetch('/latex_to_pdf', { 
                            method: 'POST', 
                            body: fd, 
                            credentials: 'include' 
                        });
                        
                        if (!res.ok) {
                            throw new Error('Failed to generate PDF from LaTeX');
                        }
                        
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        iframe.src = url;
                        loadingDiv.style.display = 'none';
                        iframe.style.display = 'block';
                        iframe.dataset.blobUrl = url;
                        
                        // Store PDF blob if "Attach to packet" is selected
                        const attachment = '${latexPreviewAttachment}';
                        if (attachment === 'Attach to packet') {
                            if (!window.latexPdfs) {
                                window.latexPdfs = {};
                            }
                            window.latexPdfs[${questionId}] = blob;
                        }
                    } catch (error) {
                        loadingDiv.innerHTML = '<p style="color: #c62828;">Failed to generate PDF from LaTeX. Please check your LaTeX code and try again.</p>';
                        iframe.style.display = 'none';
                    }
                } else {
                    // Hide preview if trigger doesn't match
                    previewDiv.style.display = 'none';
                    iframe.style.display = 'none';
                    // Clean up blob URL
                    if (iframe.dataset.blobUrl) {
                        URL.revokeObjectURL(iframe.dataset.blobUrl);
                        iframe.dataset.blobUrl = '';
                        iframe.src = '';
                    }
                    // Remove stored PDF blob if user changes away from trigger
                    if (window.latexPdfs && window.latexPdfs[${questionId}]) {
                        delete window.latexPdfs[${questionId}];
                    }
                }
            }
        </script>
    `;
}
```

Key Patterns:
- Function name: `handleLatexPreview{questionId}(value)`
- LaTeX content is escaped for JavaScript string embedding
- Form data is collected and sent to `/latex_to_pdf` endpoint
- PDF blob is stored in `window.latexPdfs[questionId]` if "Attach to packet" is selected
- Blob URLs are cleaned up when preview is hidden

3.3 ADDING HANDLER TO DROPDOWN
-------------------------------
Location: Dropdown generation in `getFormHTML()` function (around line 1342)

When a dropdown is generated, if LaTeX preview is enabled, the handler function call
is added to the dropdown's `onchange` attribute.

Implementation:

```javascript
// Build onchange attribute
let latexPreviewHandlerCall = '';
if (latexPreviewEnabled) {
    const latexPreviewTriggerEl = qBlock.querySelector(`#latexPreviewTrigger${questionId}`);
    const latexPreviewContentEl = qBlock.querySelector(`#latexPreviewContent${questionId}`);
    const latexPreviewTrigger = latexPreviewTriggerEl ? latexPreviewTriggerEl.value : "";
    const latexPreviewContent = latexPreviewContentEl ? latexPreviewContentEl.value : "";
    
    // Only include handler call if both trigger and content are set
    if (latexPreviewTrigger && latexPreviewContent) {
        latexPreviewHandlerCall = ` handleLatexPreview${questionId}(this.value)`;
    }
}

// Add to select element
select.setAttribute('onchange', `dropdownMirror(...); ...;${latexPreviewHandlerCall}`);
```

3.4 EMBEDDING LATEX PREVIEW QUESTIONS METADATA
----------------------------------------------
Location: Global variables section in `getFormHTML()` function (around line 5406)

The `latexPreviewQuestions` array must be embedded in the generated HTML for cart
integration.

Implementation:

```javascript
formHTML += `window.latexPreviewQuestions = ${JSON.stringify(latexPreviewQuestions || [])};\n`;
```

This array contains metadata for LaTeX previews that should be added to the cart:
```javascript
window.latexPreviewQuestions = [
    {
        questionId: 1,
        title: "Latex PDF Preview",
        filename: "Demand Letter",
        priceId: "price_1SqS2XFJeSRMFQ8XXlBzhcqW",
        trigger: "No"
    }
];
```

================================================================================
PART 4: CART INTEGRATION (FormWiz GUI/generate.js)
================================================================================

4.1 ADDING LATEX PDFS TO CART
------------------------------
Location: `addFormToCart()` function (around line 9119)

When adding items to the cart, LaTeX preview PDFs are converted to base64 and added
as cart items.

Implementation:

```javascript
// Add LaTeX preview PDFs to cart (if "Attach to packet" is selected)
// Convert blobs to base64 before saving to ensure they persist through JSON serialization
if (window.latexPreviewQuestions && window.latexPreviewQuestions.length > 0 && window.latexPdfs) {
    const processedQuestionIds = new Set(); // Track processed questionIds to avoid duplicates
    const latexCartItems = []; // Collect LaTeX items separately to convert blobs
    
    for (const latexPreviewQ of window.latexPreviewQuestions) {
        // Skip if we've already processed this questionId
        if (processedQuestionIds.has(latexPreviewQ.questionId)) {
            continue;
        }
        const latexPdf = window.latexPdfs[latexPreviewQ.questionId];
        // Use filename if available, otherwise fall back to title
        const filename = latexPreviewQ.filename;
        const displayName = (filename && typeof filename === 'string' && filename.trim() !== '') 
            ? filename.trim() 
            : latexPreviewQ.title;
        
        if (latexPdf && displayName && latexPreviewQ.priceId) {
            processedQuestionIds.add(latexPreviewQ.questionId);
            const pdfName = displayName.endsWith('.pdf') ? displayName : (displayName + '.pdf');
            
            // Store item with blob for async conversion
            latexCartItems.push({
                blob: latexPdf,
                cartItem: {
                    formId: displayName.replace(/\.pdf$/i, '').toLowerCase(),
                    title: displayName,
                    priceId: latexPreviewQ.priceId,
                    pdfName: pdfName,
                    originalFormId: originalFormId,
                    portfolioId: portfolioId,
                    formData: formData,
                    countyName: countyName,
                    defendantName: defendantName,
                    timestamp: nowTs,
                    isLatexPreview: true,
                    latexPdfQuestionId: latexPreviewQ.questionId
                }
            });
        }
    }
    
    // Convert all blobs to base64 before adding to cart
    if (latexCartItems.length > 0) {
        const blobToBase64 = (blob) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    const result = reader.result;
                    const base64 = result.includes(',') ? result.split(',')[1] : result;
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        };
        
        // Convert all blobs in parallel
        const conversionPromises = latexCartItems.map(async (item) => {
            const base64 = await blobToBase64(item.blob);
            return {
                ...item.cartItem,
                latexPdfBase64: base64
            };
        });
        
        // Wait for all conversions, then add to cart
        const convertedItems = await Promise.all(conversionPromises);
        cart.push(...convertedItems);
    }
}
```

Key Patterns:
- Blobs are converted to base64 for JSON serialization
- Filename is used for cart entry title (falls back to title if filename is empty)
- `isLatexPreview: true` flag identifies LaTeX PDF items
- `latexPdfBase64` contains the serialized PDF data
- Duplicate entries for the same questionId are prevented

4.2 CART SAVING WITH BASE64 CONVERSION
---------------------------------------
Location: `saveCart()` function in `cart.js` (around line 75)

When saving the cart, any LaTeX PDF blobs are converted to base64 before serialization.

Implementation:

```javascript
async saveCart() {
    // Convert LaTeX PDF blobs to base64 before serialization
    const cartToSave = await Promise.all(this.cart.map(async (item) => {
        if (item.isLatexPreview && item._latexPdfBlob && item._latexPdfBlob instanceof Blob) {
            // Convert blob to base64
            const base64 = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    const result = reader.result;
                    const base64Data = result.includes(',') ? result.split(',')[1] : result;
                    resolve(base64Data);
                };
                reader.onerror = reject;
                reader.readAsDataURL(item._latexPdfBlob);
            });
            
            // Create a copy without the blob, but with base64
            const { _latexPdfBlob, ...itemWithoutBlob } = item;
            return {
                ...itemWithoutBlob,
                latexPdfBase64: base64
            };
        }
        // Remove blob reference if it exists (for items that were already converted)
        const { _latexPdfBlob, ...itemWithoutBlob } = item;
        return itemWithoutBlob;
    }));
    
    const cartData = JSON.stringify(cartToSave);
    // Save to cookies and localStorage
    this.setCookie(this.cartCookieName, cartData, 30);
    localStorage.setItem(this.cartCookieName, cartData);
}
```

Key Patterns:
- Function is async to handle blob-to-base64 conversion
- Temporary `_latexPdfBlob` property is removed before serialization
- Base64 data is stored in `latexPdfBase64` property

================================================================================
PART 5: PAYMENT PROCESSING (FormWiz GUI/Pages/cart.js)
================================================================================

5.1 PROCESSING LATEX PDFS DURING PAYMENT
-----------------------------------------
Location: `processFormPDF()` function (around line 691)

When processing payment, LaTeX preview PDFs are restored from base64 and saved to
Firebase Storage and user documents.

Implementation:

```javascript
async processFormPDF(cartItem) {
    try {
        let blob;
        
        // Check if this is a LaTeX preview PDF (client-side generated blob)
        if (cartItem.isLatexPreview) {
            console.log(' [LATEX PDF] Processing LaTeX preview PDF:', cartItem.title);
            
            // Try to get blob from cart item first (if it wasn't serialized)
            if (cartItem.latexPdf && cartItem.latexPdf instanceof Blob) {
                blob = cartItem.latexPdf;
            } 
            // If blob was lost during serialization, restore from base64
            else if (cartItem.latexPdfBase64) {
                console.log(' [LATEX PDF] Restoring blob from base64');
                // Convert base64 back to blob
                const byteCharacters = atob(cartItem.latexPdfBase64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                blob = new Blob([byteArray], { type: 'application/pdf' });
            } else {
                throw new Error('LaTeX PDF blob not found in cart item');
            }
        } else {
            // Regular PDF: fetch from server
            console.log(' [REGULAR PDF] Processing regular PDF:', cartItem.title);
            const formData = new FormData();
            if (cartItem.formData) {
                for (const k in cartItem.formData) formData.append(k, cartItem.formData[k]);
            }
            const base = cartItem.formId.replace(/\.pdf$/i, '');
            const res = await fetch('/edit_pdf?pdf=' + encodeURIComponent(base), {
                method: 'POST',
                body: formData,
                mode: 'cors'
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            blob = await res.blob();
        }
        
        // Download the PDF
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const safeFormId = cartItem.formId.replace(/\W+/g, '_');
        const docId = `${Date.now()}_${safeFormId}`;
        // Use the proper filename for LaTeX preview PDFs
        const downloadFilename = cartItem.isLatexPreview 
            ? (cartItem.pdfName || cartItem.title || cartItem.formId) 
            : `Edited_${cartItem.formId}`;
        a.download = downloadFilename.endsWith('.pdf') ? downloadFilename : `${downloadFilename}.pdf`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        // Save to Firebase Storage and documents collection
        if (typeof firebase !== 'undefined' && firebase.auth && firebase.firestore && firebase.storage) {
            const user = firebase.auth().currentUser;
            if (user) {
                const storage = firebase.storage();
                const db = firebase.firestore();
                const meta = { contentType: 'application/pdf', customMetadata: { uploadedBy: user.uid } };
                const file = new File([blob], `${docId}.pdf`, { type: 'application/pdf' });
                const ref = storage.ref().child(`users/${user.uid}/documents/${docId}.pdf`);
                await ref.put(file, meta);
                const downloadUrl = await ref.getDownloadURL();
                
                // Save document metadata
                const documentData = {
                    name: cartItem.title,
                    formId: cartItem.formId,
                    originalFormId: cartItem.originalFormId || cartItem.formId,
                    portfolioId: cartItem.portfolioId || null,
                    countyName: cartItem.countyName || null,
                    defendantName: cartItem.defendantName || null,
                    purchaseDate: firebase.firestore.FieldValue.serverTimestamp(),
                    downloadUrl
                };
                
                await db.collection('users').doc(user.uid)
                    .collection('documents').doc(docId).set(documentData);
            }
        }
    } catch (e) {
        console.error(`PDF process error for ${cartItem.formId}`, e);
    }
}
```

Key Patterns:
- LaTeX PDFs are detected by `isLatexPreview: true` flag
- Blob is restored from `latexPdfBase64` if not already a Blob
- Download filename uses `pdfName` or `title` (not `formId`)
- PDF is saved to Firebase Storage and documents collection
- Same process as regular PDFs, but blob source is different

================================================================================
PART 6: DATA FLOW SUMMARY
================================================================================

1. USER CONFIGURATION (GUI):
   - User checks "Enable Latex Preview" checkbox
   - User selects trigger option from dropdown
   - User enters preview title and filename (for cart)
   - User pastes LaTeX code
   - User enters Stripe price ID
   - User selects "Attach to packet" or "Preview Only"
   - Data is saved to UI elements

2. AUTOSAVE:
   - Data is saved to Firebase/localStorage automatically
   - Uses `window.requestAutosave()` function

3. EXPORT (Generate JSON):
   - `download.js` reads from UI elements
   - Adds `latexPreview: {enabled, trigger, title, filename, content, priceId, attachment}` to question object
   - Exported in JSON format

4. IMPORT (Load JSON):
   - Reads `latexPreview` property from imported JSON
   - Restores to UI elements
   - Calls `toggleLatexPreview()` to populate trigger dropdown
   - Sets all field values

5. FORM GENERATION:
   - `generate.js` collects LaTeX preview data from UI elements
   - Stores metadata in `latexPreviewQuestions` array if "Attach to packet" is selected
   - Generates `handleLatexPreview{questionId}()` function
   - Adds function call to dropdown's `onchange` attribute
   - Embeds `window.latexPreviewQuestions` in generated HTML

6. RUNTIME (Generated Form):
   - User selects trigger option in dropdown
   - `handleLatexPreview{questionId}()` is called
   - Function collects form data and sends to `/latex_to_pdf` endpoint
   - Server generates PDF from LaTeX with placeholder replacement
   - PDF blob is returned and displayed in iframe
   - If "Attach to packet", blob is stored in `window.latexPdfs[questionId]`

7. CART ADDITION:
   - When form is submitted, `addFormToCart()` is called
   - LaTeX PDFs are converted to base64 and added to cart
   - Cart is saved with `latexPdfBase64` property
   - Filename is used for cart entry title

8. PAYMENT PROCESSING:
   - Cart is loaded from cookies/localStorage
   - `processFormPDF()` detects LaTeX PDFs by `isLatexPreview` flag
   - Blob is restored from `latexPdfBase64`
   - PDF is downloaded and saved to Firebase Storage
   - Document metadata is saved to user's documents collection

================================================================================
PART 7: KEY PATTERNS AND CONVENTIONS
================================================================================

7.1 NAMING CONVENTIONS
----------------------
- Checkbox ID: `enableLatexPreview{questionId}`
- Container ID: `latexPreviewBlock{questionId}`
- Trigger dropdown ID: `latexPreviewTrigger{questionId}`
- Title input ID: `latexPreviewTitle{questionId}`
- Filename input ID: `latexPreviewFilename{questionId}`
- Content textarea ID: `latexPreviewContent{questionId}`
- Price ID input ID: `latexPreviewPriceId{questionId}`
- Attachment dropdown ID: `latexPreviewAttachment{questionId}`
- Handler function: `handleLatexPreview{questionId}(value)`
- Preview div ID: `latexPreview{questionId}`
- Iframe ID: `latexPreviewIframe{questionId}`
- Loading div ID: `latexPreviewLoading{questionId}`
- Window object: `window.latexPdfs` (runtime) and `window.latexPreviewQuestions` (metadata)

7.2 DATA STRUCTURE
------------------
GUI Storage (in UI elements):
- Title: Text input value
- Filename: Text input value (for cart entry name)
- Content: Textarea value (LaTeX code)
- Trigger: Dropdown selected value
- Price ID: Text input value
- Attachment: Dropdown selected value ("Preview Only" or "Attach to packet")

Runtime Storage:
```javascript
window.latexPdfs = {
    1: Blob  // Key: questionId, Value: PDF blob
}

window.latexPreviewQuestions = [
    {
        questionId: 1,
        title: "Latex PDF Preview",
        filename: "Demand Letter",
        priceId: "price_1SqS2XFJeSRMFQ8XXlBzhcqW",
        trigger: "No"
    }
]
```

Cart Item Structure:
```javascript
{
    formId: "demand letter",
    title: "Demand Letter",
    priceId: "price_1SqS2XFJeSRMFQ8XXlBzhcqW",
    pdfName: "Demand Letter.pdf",
    isLatexPreview: true,
    latexPdfBase64: "JVBERi0xLjQKJeLjz9MKMSAwIG9iago8PC9UeXBlL0NhdGFsb2cvUGFnZXMgMiAwIFI+PgplbmRvYmoK...",
    latexPdfQuestionId: 1,
    originalFormId: "sc100",
    portfolioId: "msZI0AYG41EFiglBoB6b",
    formData: {...},
    countyName: "Monterey",
    defendantName: "123",
    timestamp: 1768901811569
}
```

7.3 BLOB SERIALIZATION PATTERN
-------------------------------
Problem: Blob objects cannot be serialized to JSON for cookies/localStorage.

Solution: Convert blobs to base64 strings before serialization, restore from base64
when needed.

Conversion to Base64:
```javascript
const blobToBase64 = (blob) => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            const result = reader.result;
            const base64 = result.includes(',') ? result.split(',')[1] : result;
            resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
};
```

Restoration from Base64:
```javascript
const byteCharacters = atob(cartItem.latexPdfBase64);
const byteNumbers = new Array(byteCharacters.length);
for (let i = 0; i < byteCharacters.length; i++) {
    byteNumbers[i] = byteCharacters.charCodeAt(i);
}
const byteArray = new Uint8Array(byteNumbers);
const blob = new Blob([byteArray], { type: 'application/pdf' });
```

7.4 FILENAME VS TITLE PATTERN
------------------------------
- **Title**: Displayed in the preview header (e.g., "Latex PDF Preview")
- **Filename**: Used for cart entry name (e.g., "Demand Letter")
- **Fallback**: If filename is empty, title is used for cart entry
- **Cart Display**: Cart shows the filename (or title if filename is empty)
- **Document Name**: Saved document uses the filename/title from cart item

7.5 DUPLICATE PREVENTION PATTERN
---------------------------------
- Use `Set` to track processed questionIds
- Check for existing entries before adding to `latexPreviewQuestions`
- Remove existing entries before adding new ones if questionId matches
- Prevents multiple cart entries for the same LaTeX preview

================================================================================
PART 8: COMMON GOTCHAS AND TROUBLESHOOTING
================================================================================

GOTCHA 1: Blob Lost During Cart Serialization
-----------------------------------------------
Problem: LaTeX PDF blob is lost when cart is saved to cookies/localStorage.

Solution: Convert blob to base64 before saving. The `addFormToCart()` function must
be async and await the base64 conversion before saving the cart. The `saveCart()`
function in `cart.js` also converts any remaining blobs to base64.

GOTCHA 2: PDF Not Added to Cart
--------------------------------
Problem: LaTeX PDF is generated but not added to cart.

Solution: Ensure "Attach to packet" is selected (not "Preview Only"). Check that
`window.latexPreviewQuestions` contains the question metadata and `window.latexPdfs`
contains the blob for the questionId.

GOTCHA 3: PDF Not Downloaded After Payment
-------------------------------------------
Problem: Payment succeeds but LaTeX PDF is not downloaded or saved to documents.

Solution: Ensure `processFormPDF()` checks for `isLatexPreview` flag and restores
blob from `latexPdfBase64`. Check that base64 conversion happened during cart save.
Verify that the blob restoration code is working correctly.

GOTCHA 4: Wrong Filename in Cart
---------------------------------
Problem: Cart shows "Latex PDF Preview" instead of "Demand Letter".

Solution: Ensure filename field is read correctly in `generate.js`. Check that
filename defaults to title if empty. Verify that `displayName` uses filename
when creating cart items.

GOTCHA 5: Duplicate Cart Entries
----------------------------------
Problem: Multiple entries for the same LaTeX preview appear in cart.

Solution: Ensure duplicate prevention logic is in place. Check that `processedQuestionIds`
Set is used to track processed questionIds. Verify that existing entries are removed
before adding new ones in `latexPreviewQuestions.push()`.

GOTCHA 6: Base64 Conversion Fails
----------------------------------
Problem: Cart save fails or PDF is not restored from base64.

Solution: Ensure `addFormToCart()` is async and awaits base64 conversion. Check
that `saveCart()` in `cart.js` is also async and handles blob conversion. Verify
that FileReader is available and working correctly.

GOTCHA 7: PDF Generation Fails
-------------------------------
Problem: Preview shows error message instead of PDF.

Solution: Check that `/latex_to_pdf` endpoint exists and is working. Verify that
LaTeX code is valid and doesn't contain syntax errors. Check that form data is
being collected correctly for placeholder replacement. Ensure server can process
LaTeX and return PDF blob.

GOTCHA 8: Placeholder Replacement Not Working
----------------------------------------------
Problem: LaTeX PDF shows [user_fullname] instead of actual name.

Solution: Ensure form data collection includes all form elements (including external
elements with `form="customForm"` attribute). Verify that placeholder names match
form field names. Check that date fields are formatted correctly using `formatDateForServer()`.

================================================================================
PART 9: SERVER ENDPOINT REQUIREMENTS
================================================================================

The LaTeX preview feature requires a server endpoint `/latex_to_pdf` that:

1. Accepts POST requests with FormData containing:
   - `latex`: The LaTeX code string
   - Form field values: All form fields as key-value pairs

2. Processes the LaTeX code:
   - Replaces placeholders like `[user_fullname]` with actual form values
   - Compiles LaTeX to PDF using a LaTeX processor (e.g., pdflatex)
   - Handles errors gracefully

3. Returns:
   - PDF blob with `Content-Type: application/pdf`
   - Error response if LaTeX compilation fails

Example endpoint implementation (pseudo-code):
```javascript
app.post('/latex_to_pdf', async (req, res) => {
    try {
        const latexCode = req.body.latex;
        const formData = req.body; // All form fields
        
        // Replace placeholders in LaTeX code
        let processedLatex = latexCode;
        for (const [key, value] of Object.entries(formData)) {
            if (key !== 'latex') {
                const placeholder = `[${key}]`;
                processedLatex = processedLatex.replace(new RegExp(placeholder, 'g'), value || '');
            }
        }
        
        // Compile LaTeX to PDF (using pdflatex or similar)
        const pdfBuffer = await compileLatexToPdf(processedLatex);
        
        // Return PDF blob
        res.setHeader('Content-Type', 'application/pdf');
        res.send(pdfBuffer);
    } catch (error) {
        res.status(500).json({ error: 'Failed to generate PDF from LaTeX' });
    }
});
```

================================================================================
END OF FEATURE #4 DOCUMENTATION
================================================================================

================================================================================
FEATURE #5: ZIPCODE-TO-COUNTY HIDDEN FIELD FOR LOCATION INPUTS
================================================================================

PURPOSE:
--------
Automatically derives a county name from any location zip code field and stores it
in a hidden textbox. This supports dynamic, numbered location fields without
hard-coding any question IDs.

Example:
- Zip field: how_many_extra_plaintiffs_are_there_please_enter_their_address_zip_1
- Hidden county field created/updated:
  how_many_extra_plaintiffs_are_there_please_enter_their_address_county_1

CONTEXT:
--------
This feature uses the same zip->county mapping data used by the court lookup
integration (CountyLookup). It applies to all inputs whose IDs match the pattern:
- *_zip
- *_zip_<number>

================================================================================
PART 1: RUNTIME FUNCTIONALITY (Generated HTML)
================================================================================

1.1 DYNAMIC COUNTY UPDATE FUNCTION
-----------------------------------
Location: Generated HTML script block in `generate.js` (county lookup section)

Purpose:
- Derive county from zip code for ANY zip input
- Create the hidden county field if it does not exist
- Update county value on input/change and on page load

Implementation:
```javascript
function updateCountyForZipInput(zipInput) {
    if (!zipInput || !zipInput.id) return;
    var match = zipInput.id.match(/^(.*)_zip(?:_(\d+))?$/);
    if (!match) return;

    var zipCode = (zipInput.value || "").trim();
    var prefix = match[1];
    var suffix = match[2] ? "_" + match[2] : "";
    var countyFieldId = prefix + "_county" + suffix;
    var countyField = document.getElementById(countyFieldId);

    if (!countyField) {
        countyField = document.createElement("input");
        countyField.type = "text";
        countyField.id = countyFieldId;
        countyField.name = countyFieldId;
        countyField.style.display = "none";
        var formEl = document.getElementById("customForm");
        if (formEl) formEl.appendChild(countyField);
    }

    if (zipCode.length === 5) {
        var county = zipCodeToCountyLocal[zipCode];
        countyField.value = county ? (county + " County") : "";
    } else {
        countyField.value = "";
    }
}
```

1.2 INITIAL LOAD + EVENT LISTENERS
-----------------------------------
Location: Generated HTML script block in `generate.js`

Implementation:
```javascript
document.addEventListener("DOMContentLoaded", function() {
    const allZipFields = document.querySelectorAll('input[id$="_zip"], input[id*="_zip_"]');
    allZipFields.forEach(function(el) { updateCountyForZipInput(el); });
});

document.addEventListener("input", function(e) {
    if (e && e.target && e.target.id && /_zip(?:_\d+)?$/.test(e.target.id)) {
        updateCountyForZipInput(e.target);
    }
});

document.addEventListener("change", function(e) {
    if (e && e.target && e.target.id && /_zip(?:_\d+)?$/.test(e.target.id)) {
        updateCountyForZipInput(e.target);
    }
});
```

Key Patterns:
- Matches dynamic IDs using a regex; no hard-coded question IDs
- Uses the same zip lookup data as court lookup (`zipCodeToCountyLocal`)
- Creates hidden fields on-the-fly to avoid HTML generation changes

================================================================================
PART 2: DATA FLOW SUMMARY
================================================================================

1. User types in any location zip field.
2. `updateCountyForZipInput()` derives the county from zip.
3. Hidden `*_county` field is created (if missing) and updated.
4. On reload, all existing zip fields are scanned and populated.

================================================================================
PART 3: KEY PATTERNS AND CONVENTIONS
================================================================================

3.1 NAMING CONVENTIONS
----------------------
- Zip field: `{prefix}_zip` or `{prefix}_zip_{n}`
- County field: `{prefix}_county` or `{prefix}_county_{n}`

3.2 DEPENDENCIES
----------------
- `zipCodeToCountyLocal` must be defined and populated from CountyLookup data.
- County value stored as "<County> County" for consistency with other fields.

================================================================================
END OF FEATURE #5 DOCUMENTATION
================================================================================
