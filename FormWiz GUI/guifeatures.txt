================================================================================
GUI FEATURES DOCUMENTATION
================================================================================
This document provides detailed, step-by-step documentation for GUI features
that can be replicated in other contexts. Each feature is documented with:
- Purpose and behavior
- UI components and layout
- Data storage structure
- Complete implementation details
- Export/import process
- Runtime behavior
- Common patterns and gotchas

================================================================================
FEATURE #1: ENABLE ALERT FOR TRIGGER DROPDOWN FIELDS
================================================================================

PURPOSE:
--------
Allows form builders to configure conditional alerts on dropdown fields within
trigger sequences. When a user selects a specific option in the generated form,
a custom modal alert is displayed with a custom message.

Example: A dropdown "Are they a public entity?" has options "Yes" and "No".
The form builder can enable an alert so that when users select "Yes", they see
an alert message like "public entities are cool".

CONTEXT:
--------
This feature is implemented for dropdown fields within trigger sequences.
Trigger sequences are conditional fields that appear when a parent dropdown
has a specific value. For example, if "Are they a business or public entity?"
is set to "Yes", a trigger sequence appears with additional fields including
the "Are they a public entity?" dropdown.

================================================================================
PART 1: GUI INTERFACE (FormWiz GUI/gui.js)
================================================================================

1.1 ADDING THE UI CHECKBOX
---------------------------
Location: `addTriggerDropdown()` function (around line 3197)

When a dropdown field is added to a trigger sequence, an "Enable Alert" checkbox
is added right after the "Enable Conditional Logic" checkbox.

UI Structure:
```html
<div style="margin-bottom: 8px; text-align: center;">
    <label for="enableAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}">
        Enable Alert
    </label>
    <div style="display: flex; justify-content: center;">
        <input type="checkbox" 
               id="enableAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}"
               onchange="toggleTriggerDropdownAlert({questionId}, {fieldCount}, {sequenceCount}, {triggerFieldCount})">
    </div>
    <div id="alertUIDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}" 
         style="margin-top: 8px; display: none;">
        <!-- Alert UI will be populated here -->
    </div>
</div>
```

Key Patterns:
- Checkbox ID pattern: `enableAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Container ID pattern: `alertUIDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Container is initially hidden (`display: none`)
- The toggle function is called on checkbox `onchange` event

1.2 TOGGLE FUNCTION
-------------------
Location: `toggleTriggerDropdownAlert()` function (around line 3850)

Purpose: Shows/hides the alert configuration UI and manages the data structure.

Function Signature:
```javascript
function toggleTriggerDropdownAlert(questionId, fieldCount, sequenceCount, triggerFieldCount)
```

Implementation Steps:

Step 1: Get DOM Elements
```javascript
const checkbox = document.getElementById(`enableAlertDropdown${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
const container = document.getElementById(`alertUIDropdown${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
```

Step 2: Initialize Data Structure
```javascript
if (!window.triggerDropdownAlert) {
    window.triggerDropdownAlert = {};
}
const key = `${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`;
if (!window.triggerDropdownAlert[key]) {
    window.triggerDropdownAlert[key] = { enabled: false, condition: '', title: '' };
}
```

Step 3: Update Enabled State and Show/Hide UI
```javascript
container.style.display = checkbox.checked ? 'block' : 'none';
window.triggerDropdownAlert[key].enabled = checkbox.checked;
```

Step 4: Call Update Function if Enabled
```javascript
if (checkbox.checked) {
    updateTriggerDropdownAlertUI(questionId, fieldCount, sequenceCount, triggerFieldCount);
} else {
    // Clear alert data when disabled
    window.triggerDropdownAlert[key].condition = '';
    window.triggerDropdownAlert[key].title = '';
}
```

Step 5: Trigger Autosave
```javascript
if (typeof window.requestAutosave === 'function') {
    window.requestAutosave();
}
```

Data Storage Key Pattern:
- Format: `"{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}"`
- Example: `"1_5_1_4"` means question 1, field 5, sequence 1, trigger field 4
- Stored in: `window.triggerDropdownAlert[key]`

1.3 UPDATE UI FUNCTION
----------------------
Location: `updateTriggerDropdownAlertUI()` function (around line 3880)

Purpose: Populates the alert configuration UI with:
1. A dropdown to select which option triggers the alert (populated from the dropdown's options)
2. A text input for the alert message

Function Signature:
```javascript
function updateTriggerDropdownAlertUI(questionId, fieldCount, sequenceCount, triggerFieldCount)
```

Implementation Steps:

Step 1: Get Container and Initialize Data Structure
```javascript
const container = document.getElementById(`alertUIDropdown${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
if (!container) return;

if (!window.triggerDropdownAlert) {
    window.triggerDropdownAlert = {};
}
const key = `${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`;
if (!window.triggerDropdownAlert[key]) {
    window.triggerDropdownAlert[key] = { enabled: true, condition: '', title: '' };
}
```

Step 2: Get Dropdown Options from the Parent Field
```javascript
const optionsContainer = document.getElementById(`triggerDropdownOptions${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
const options = [];
if (optionsContainer) {
    const optionInputs = optionsContainer.querySelectorAll('input[type="text"]');
    optionInputs.forEach(input => {
        const optionText = input.value.trim();
        if (optionText) {
            options.push(optionText);
        }
    });
}
```

Key Pattern: Options are read from the DOM, not from a data structure. This means
the options container must exist and be populated before calling this function.

Step 3: Clear Container and Create Alert Condition Dropdown
```javascript
container.innerHTML = '';

const conditionRow = document.createElement('div');
conditionRow.style.cssText = 'margin-bottom: 8px; display: flex; flex-direction: column; align-items: center; gap: 4px;';

const conditionLabel = document.createElement('label');
conditionLabel.textContent = 'Alert Condition:';
conditionLabel.style.cssText = 'font-weight: bold; color: #333; font-size: 12px;';
conditionRow.appendChild(conditionLabel);

const conditionDropdown = document.createElement('select');
conditionDropdown.style.cssText = 'width: 70%; max-width: 300px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 12px;';

// Add placeholder option
const placeholderOption = document.createElement('option');
placeholderOption.value = '';
placeholderOption.textContent = 'Select option...';
conditionDropdown.appendChild(placeholderOption);

// Add options from the dropdown field
options.forEach(optionText => {
    const option = document.createElement('option');
    option.value = optionText;
    option.textContent = optionText;
    if (window.triggerDropdownAlert[key].condition === optionText) {
        option.selected = true;
    }
    conditionDropdown.appendChild(option);
});
```

Step 4: Add Change Handler for Condition Dropdown
```javascript
conditionDropdown.value = window.triggerDropdownAlert[key].condition || '';
conditionDropdown.onchange = () => {
    if (!window.triggerDropdownAlert[key]) {
        window.triggerDropdownAlert[key] = { enabled: true, condition: '', title: '' };
    }
    window.triggerDropdownAlert[key].condition = conditionDropdown.value;
    // Trigger autosave
    if (typeof window.requestAutosave === 'function') {
        window.requestAutosave();
    }
};
conditionRow.appendChild(conditionDropdown);
container.appendChild(conditionRow);
```

Step 5: Create Alert Title Input
```javascript
const titleRow = document.createElement('div');
titleRow.style.cssText = 'margin-bottom: 8px; display: flex; flex-direction: column; align-items: center; gap: 4px;';

const titleLabel = document.createElement('label');
titleLabel.textContent = 'Alert Title:';
titleLabel.style.cssText = 'font-weight: bold; color: #333; font-size: 12px;';
titleRow.appendChild(titleLabel);

const titleInput = document.createElement('input');
titleInput.type = 'text';
titleInput.placeholder = 'Enter alert message...';
titleInput.style.cssText = 'width: 70%; max-width: 300px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 12px;';
titleInput.value = window.triggerDropdownAlert[key].title || '';
```

Step 6: Add Change/Blur Handlers for Title Input
```javascript
titleInput.onchange = () => {
    if (!window.triggerDropdownAlert[key]) {
        window.triggerDropdownAlert[key] = { enabled: true, condition: '', title: '' };
    }
    window.triggerDropdownAlert[key].title = titleInput.value.trim();
    if (typeof window.requestAutosave === 'function') {
        window.requestAutosave();
    }
};
titleInput.onblur = () => {
    // Same as onchange - ensures data is saved even if user tabs away
    if (!window.triggerDropdownAlert[key]) {
        window.triggerDropdownAlert[key] = { enabled: true, condition: '', title: '' };
    }
    window.triggerDropdownAlert[key].title = titleInput.value.trim();
    if (typeof window.requestAutosave === 'function') {
        window.requestAutosave();
    }
};
titleRow.appendChild(titleInput);
container.appendChild(titleRow);
```

Important Patterns:
- Both `onchange` and `onblur` handlers are used to ensure data is saved
- Always check if the data structure exists before accessing it
- Always trigger autosave after data changes
- The condition dropdown is populated from the actual dropdown options in the DOM

================================================================================
PART 2: EXPORT/IMPORT (FormWiz GUI/download.js)
================================================================================

2.1 EXPORT PROCESS
------------------
Location: Field collection code in `getFormJSON()` function (around line 1885-1950)

When collecting trigger dropdown field data for JSON export, alert data must be
collected from `window.triggerDropdownAlert` and added to the `dropdownField` object.

Implementation:

Step 1: Find the Alert Data
```javascript
// After collecting dropdown options and conditional logic
const dropdownField = {
    type: 'dropdown',
    fieldName: dropdownFieldNameEl.value.trim(),
    options: dropdownOptions
};

// Check for alert data
const alertKey = `${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`;
let alertEnabled = false;
let storedAlertData = null;

if (window.triggerDropdownAlert && window.triggerDropdownAlert[alertKey]) {
    const storedAlert = window.triggerDropdownAlert[alertKey];
    alertEnabled = storedAlert.enabled || false;
    if (alertEnabled && (storedAlert.condition || storedAlert.title)) {
        storedAlertData = {
            condition: storedAlert.condition || '',
            title: storedAlert.title || ''
        };
    }
}
```

Step 2: Check Checkbox State as Fallback
```javascript
// Also check checkbox state as fallback
if (!alertEnabled) {
    const enableAlertCheckbox = fieldEl.querySelector(`#enableAlertDropdown${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`);
    alertEnabled = enableAlertCheckbox && enableAlertCheckbox.checked;
}
```

Step 3: Add Alert Data to Field Object
```javascript
// Include alert if enabled
if (alertEnabled && storedAlertData) {
    dropdownField.alert = {
        enabled: true,
        condition: storedAlertData.condition,
        title: storedAlertData.title
    };
} else if (alertEnabled) {
    // Fallback: try to get from UI elements
    const alertContainer = fieldEl.querySelector(`#alertUIDropdown${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`);
    if (alertContainer) {
        const conditionDropdown = alertContainer.querySelector('select');
        const titleInput = alertContainer.querySelector('input[type="text"]');
        if (conditionDropdown && titleInput) {
            const condition = conditionDropdown.value.trim();
            const title = titleInput.value.trim();
            if (condition || title) {
                dropdownField.alert = {
                    enabled: true,
                    condition: condition,
                    title: title
                };
            }
        }
    }
}
```

Key Pattern: Export checks both `window.triggerDropdownAlert` (preferred) and
UI elements (fallback) to ensure data is captured even if the window object
isn't up to date.

JSON Export Format:
```json
{
    "type": "dropdown",
    "fieldName": "Are they a public entity?",
    "options": [
        {"text": "Yes"},
        {"text": "No"}
    ],
    "alert": {
        "enabled": true,
        "condition": "Yes",
        "title": "public entities are cool"
    }
}
```

2.2 IMPORT PROCESS
------------------
Location: `loadFormJson()` function, within the dropdown field restoration block
(around line 980-1070 and 1713-1831 - there are two locations for different code paths)

When importing a JSON file, alert data must be restored to `window.triggerDropdownAlert`
and the UI must be updated.

Implementation:

Step 1: Check for Alert Data in Imported JSON
```javascript
// After restoring dropdown options
if (triggerField.alert && triggerField.alert.enabled) {
    // Initialize the data structure
    const alertKey = `${question.questionId}_${fieldOrder}_${sequenceIndex + 1}_${actualFieldCount}`;
    if (!window.triggerDropdownAlert) {
        window.triggerDropdownAlert = {};
    }
    window.triggerDropdownAlert[alertKey] = {
        enabled: true,
        condition: triggerField.alert.condition || '',
        title: triggerField.alert.title || ''
    };
```

Step 2: Wait for Options to be Added
```javascript
    // Wait for options to be added before restoring alert
    setTimeout(() => {
        const enableAlertCheckbox = document.getElementById(`enableAlertDropdown${question.questionId}_${fieldOrder}_${sequenceIndex + 1}_${actualFieldCount}`);
        if (enableAlertCheckbox) {
            enableAlertCheckbox.checked = true;
            // Manually trigger the change event to update the UI
            const event = new Event('change');
            enableAlertCheckbox.dispatchEvent(event);
```

Step 3: Wait for UI to Update, Then Set Values
```javascript
            // Set the alert values after a delay to ensure UI is ready
            setTimeout(() => {
                if (typeof updateTriggerDropdownAlertUI === 'function') {
                    updateTriggerDropdownAlertUI(question.questionId, fieldOrder, sequenceIndex + 1, actualFieldCount);
                    // Set the alert values after UI is updated
                    setTimeout(() => {
                        const alertContainer = document.getElementById(`alertUIDropdown${question.questionId}_${fieldOrder}_${sequenceIndex + 1}_${actualFieldCount}`);
                        if (alertContainer) {
                            const conditionDropdown = alertContainer.querySelector('select');
                            const titleInput = alertContainer.querySelector('input[type="text"]');
                            if (conditionDropdown && triggerField.alert.condition) {
                                conditionDropdown.value = triggerField.alert.condition;
                                conditionDropdown.dispatchEvent(new Event('change'));
                            }
                            if (titleInput && triggerField.alert.title) {
                                titleInput.value = triggerField.alert.title;
                                titleInput.dispatchEvent(new Event('blur'));
                            }
                        }
                    }, 300);
                }
            }, 400);
        }
    }, 200);
}
```

Key Patterns:
- Multiple nested `setTimeout` calls ensure UI elements exist before accessing them
- Manually dispatch events to trigger handlers
- The sequence is: set checkbox -> trigger change -> wait for UI update -> set values
- Total delay chain: 200ms -> 400ms -> 300ms = 900ms total

================================================================================
PART 3: FORM GENERATION (FormWiz GUI/generate.js)
================================================================================

3.1 COLLECTING ALERT DATA DURING FORM GENERATION
-------------------------------------------------
Location: Two places where dropdown fields are collected from GUI:
1. Around line 1885-1950 (first collection point)
2. Around line 3249-3335 (second collection point)

When building `unifiedFieldsMap` from the GUI, alert data must be included.

Implementation:

```javascript
// After collecting dropdown options and conditional logic
const dropdownField = {
    type: 'dropdown',
    fieldName: dropdownFieldNameEl.value.trim(),
    options: dropdownOptions
};

// Check for alert data from window.triggerDropdownAlert
const alertKey = `${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`;
console.log('[ALERT DEBUG] Collecting alert data for key:', alertKey);

if (window.triggerDropdownAlert && window.triggerDropdownAlert[alertKey]) {
    const storedAlert = window.triggerDropdownAlert[alertKey];
    console.log('[ALERT DEBUG] Found stored alert data:', storedAlert);
    
    if (storedAlert.enabled && storedAlert.condition && storedAlert.title) {
        dropdownField.alert = {
            enabled: storedAlert.enabled,
            condition: storedAlert.condition.trim(),
            title: storedAlert.title.trim()
        };
        console.log('[ALERT DEBUG] Added alert to dropdownField:', dropdownField.alert);
        }
}
```

Key Pattern: Alert data is collected from `window.triggerDropdownAlert` using
the same key pattern used throughout the GUI. This data is then included in
the `unifiedFieldsMap` which is embedded in the generated HTML.

3.2 RUNTIME FIELD ENRICHMENT
-----------------------------
Location: `createTriggerFieldsContainer()` function in generated HTML (around line 5684)

Problem: When `createTriggerFieldsContainer` is called at runtime (when user
selects a dropdown option), it receives `fields` parameter that may not include
alert data because it comes from a different source.

Solution: Enrich the fields with data from `unifiedFieldsMap` before processing.

Implementation:

```javascript
// Helper function to enrich triggerField with data from unifiedFieldsMap
function enrichTriggerFieldWithUnifiedData(triggerField, fieldIndex) {
    // Try to find the complete field data from unifiedFieldsMap
    if (window.unifiedFieldsMap && window.unifiedFieldsMap[questionId]) {
        const allFields = window.unifiedFieldsMap[questionId];
        
        // Find the parent dropdown field that contains trigger sequences
        const parentDropdownField = allFields.find(f => 
            f.type === 'dropdown' && 
            f.triggerSequences && 
            Array.isArray(f.triggerSequences) &&
            f.triggerSequences.length > sequenceIndex
        );
        
        if (parentDropdownField) {
            const sequence = parentDropdownField.triggerSequences[sequenceIndex];
            if (sequence && sequence.fields && Array.isArray(sequence.fields)) {
                // Find the matching field by fieldName/label and type, or by index as fallback
                let matchingField = sequence.fields.find(f => 
                    f.type === triggerField.type &&
                    ((f.fieldName && triggerField.fieldName && f.fieldName === triggerField.fieldName) ||
                     (f.label && triggerField.label && f.label === triggerField.label))
                );
                
                // Fallback: try to match by index if name matching failed
                if (!matchingField && fieldIndex < sequence.fields.length) {
                    const fieldByIndex = sequence.fields[fieldIndex];
                    if (fieldByIndex && fieldByIndex.type === triggerField.type) {
                        matchingField = fieldByIndex;
                    }
                }
                
                if (matchingField) {
                    // Merge alert data and other properties from unifiedFieldsMap
                    if (matchingField.alert) {
                        triggerField.alert = matchingField.alert;
                    }
                    // Also merge conditionalLogic if it's missing
                    if (matchingField.conditionalLogic && !triggerField.conditionalLogic) {
                        triggerField.conditionalLogic = matchingField.conditionalLogic;
                    }
                }
            }
        }
    }
    return triggerField;
}

// Call enrichment before processing each field
fields.forEach((triggerField, fieldIndex) => {
    enrichTriggerFieldWithUnifiedData(triggerField, fieldIndex);
    // ... rest of field processing
});
```

Key Patterns:
- Look up data from `window.unifiedFieldsMap` at runtime
- Match fields by both name and type, with index as fallback
- Merge alert data into the triggerField object before use
- This ensures alert data is available even when fields come from different sources

3.3 RUNTIME ALERT FUNCTIONALITY
--------------------------------
Location: `createTriggerFieldsContainer()` function, within dropdown field creation
(around line 6066-6250)

When a dropdown field is created at runtime, alert functionality is added to
the change event handler.

Implementation:

Step 1: Capture Alert Data in Local Variable
```javascript
// Capture alert data in local variable to avoid closure issues
const alertData = triggerField.alert ? {
    enabled: triggerField.alert.enabled || false,
    condition: (triggerField.alert.condition || '').trim(),
    title: (triggerField.alert.title || '').trim()
} : null;
```

Key Pattern: Capture data in a local variable before creating event listeners
to avoid closure issues when iterating through fields.

Step 2: Add Alert Check to Change Handler
```javascript
select.addEventListener('change', function() {
    // Check for alert functionality if enabled
    if (alertData && alertData.enabled && alertData.condition && alertData.title) {
        const selectedValue = (this.value || '').trim();
        const alertCondition = alertData.condition;
                
        if (selectedValue === alertCondition) {
            // Use custom alert modal instead of default browser alert
            if (typeof showAlert === 'function') {
                showAlert(alertData.title);
            } else {
                // Fallback to default alert if showAlert is not available
                alert(alertData.title);
                }
        }
        }
    
    // ... rest of change handler (dropdownMirror, conditional logic, etc.)
});
```

Key Patterns:
- Check if `showAlert` function exists before using custom modal
- Trim values for comparison to avoid whitespace issues
- Alert is shown BEFORE other change handlers run
- Uses `showAlert()` function which displays a custom modal overlay

Custom Alert Modal:
The `showAlert()` function is defined in the generated HTML and displays a
custom modal with:
- Overlay background with blur effect
- Centered popup with rounded corners
- Message displayed in styled div
- "Continue" button to close

================================================================================
PART 4: DATA FLOW SUMMARY
================================================================================

1. USER CONFIGURATION (GUI):
   - User checks "Enable Alert" checkbox
   - Toggle function stores data in `window.triggerDropdownAlert[key]`
   - Update function populates UI and saves condition/title

2. AUTOSAVE:
   - Data is saved to Firebase/localStorage automatically
   - Uses `window.requestAutosave()` function

3. EXPORT (Generate JSON):
   - `download.js` reads from `window.triggerDropdownAlert`
   - Adds `alert: {enabled, condition, title}` to dropdownField
   - Exported in JSON format

4. IMPORT (Load JSON):
   - Reads `alert` property from imported JSON
   - Restores to `window.triggerDropdownAlert`
   - Updates UI checkboxes and inputs
   - Uses nested timeouts to ensure UI is ready

5. FORM GENERATION:
   - `generate.js` collects alert data from `window.triggerDropdownAlert`
   - Includes in `unifiedFieldsMap` which is embedded in HTML

6. RUNTIME (Generated Form):
   - `createTriggerFieldsContainer` enriches fields from `unifiedFieldsMap`
   - Alert data is merged into triggerField object
   - Change event handler checks condition and calls `showAlert()`
   - Custom modal is displayed to user

================================================================================
PART 5: KEY PATTERNS AND CONVENTIONS
================================================================================

5.1 NAMING CONVENTIONS
----------------------
- Checkbox ID: `enableAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Container ID: `alertUIDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Data key: `"{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}"`
- Window object: `window.triggerDropdownAlert`

Pattern to replicate for other field types:
- Replace "Dropdown" with field type (e.g., "Textbox", "Checkbox")
- Keep the rest of the pattern the same

5.2 DATA STRUCTURE
------------------
```javascript
window.triggerDropdownAlert = {
    "1_5_1_4": {  // Key: questionId_fieldCount_sequenceCount_triggerFieldCount
        enabled: true,
        condition: "Yes",  // The option value that triggers the alert
        title: "public entities are cool"  // The alert message
    }
}
```

5.3 TOGGLE FUNCTION PATTERN
----------------------------
1. Get checkbox and container elements
2. Initialize window data structure if needed
3. Show/hide container based on checkbox state
4. Update enabled state in data structure
5. Call update function if enabled, clear data if disabled
6. Trigger autosave

5.4 UPDATE FUNCTION PATTERN
----------------------------
1. Get container element
2. Initialize window data structure
3. Get dynamic options/data from parent field DOM
4. Clear container innerHTML
5. Create UI elements (dropdowns, inputs)
6. Populate with existing values from data structure
7. Add event handlers that update data structure and trigger autosave
8. Append elements to container

5.5 EXPORT PATTERN
------------------
1. Check `window.trigger{FieldType}Alert` for stored data
2. Check checkbox state as fallback
3. Check UI elements as final fallback
4. Add alert property to field object if enabled and has data
5. Include in JSON export

5.6 IMPORT PATTERN
------------------
1. Check for alert property in imported JSON
2. Restore to `window.trigger{FieldType}Alert`
3. Use setTimeout chain to wait for UI elements
4. Check checkbox and trigger change event
5. Call update function to populate UI
6. Set values in UI inputs/dropdowns
7. Dispatch events to trigger handlers

5.7 RUNTIME GENERATION PATTERN
-------------------------------
1. Collect alert data during form generation
2. Include in unifiedFieldsMap (or similar data structure)
3. At runtime, enrich field objects with data from unifiedFieldsMap
4. Capture alert data in local variable before event handlers
5. Check condition in change/input handler
6. Call custom alert function if condition matches

================================================================================
PART 6: REPLICATING FOR OTHER FIELD TYPES
================================================================================

To add alert functionality to textbox fields in trigger sequences:

STEP 1: Add UI Checkbox
-----------------------
In `addTriggerLabel()` or equivalent function, add:
```javascript
<div style="margin-bottom: 8px; text-align: center;">
    <label for="enableAlertLabel{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}">
        Enable Alert
    </label>
    <div style="display: flex; justify-content: center;">
        <input type="checkbox" 
               id="enableAlertLabel{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}"
               onchange="toggleTriggerLabelAlert({questionId}, {fieldCount}, {sequenceCount}, {triggerFieldCount})">
    </div>
    <div id="alertUILabel{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}" 
         style="margin-top: 8px; display: none;">
        <!-- Alert UI will be populated here -->
    </div>
</div>
```

STEP 2: Create Toggle Function
-------------------------------
```javascript
function toggleTriggerLabelAlert(questionId, fieldCount, sequenceCount, triggerFieldCount) {
    const checkbox = document.getElementById(`enableAlertLabel${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
    const container = document.getElementById(`alertUILabel${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
    if (!checkbox || !container) return;

    container.style.display = checkbox.checked ? 'block' : 'none';
    
    if (!window.triggerLabelAlert) {
        window.triggerLabelAlert = {};
    }
    const key = `${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`;
    if (!window.triggerLabelAlert[key]) {
        window.triggerLabelAlert[key] = { enabled: false, condition: '', title: '' };
    }
    
    window.triggerLabelAlert[key].enabled = checkbox.checked;
    
    if (checkbox.checked) {
        updateTriggerLabelAlertUI(questionId, fieldCount, sequenceCount, triggerFieldCount);
    } else {
        window.triggerLabelAlert[key].condition = '';
        window.triggerLabelAlert[key].title = '';
    }
    
    if (typeof window.requestAutosave === 'function') {
        window.requestAutosave();
    }
}
```

STEP 3: Create Update Function
-------------------------------
For textboxes, the "condition" might be:
- An exact text match
- A pattern match
- A length check
- etc.

Adjust the UI accordingly. For exact match, use a text input instead of dropdown:
```javascript
function updateTriggerLabelAlertUI(questionId, fieldCount, sequenceCount, triggerFieldCount) {
    const container = document.getElementById(`alertUILabel${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`);
    if (!container) return;
    
    if (!window.triggerLabelAlert) {
        window.triggerLabelAlert = {};
    }
    const key = `${questionId}_${fieldCount}_${sequenceCount}_${triggerFieldCount}`;
    if (!window.triggerLabelAlert[key]) {
        window.triggerLabelAlert[key] = { enabled: true, condition: '', title: '' };
    }
    
    container.innerHTML = '';
    
    // Condition input (exact text match example)
    const conditionRow = document.createElement('div');
    conditionRow.style.cssText = 'margin-bottom: 8px; display: flex; flex-direction: column; align-items: center; gap: 4px;';
    
    const conditionLabel = document.createElement('label');
    conditionLabel.textContent = 'Alert Condition (exact text):';
    conditionLabel.style.cssText = 'font-weight: bold; color: #333; font-size: 12px;';
    conditionRow.appendChild(conditionLabel);
    
    const conditionInput = document.createElement('input');
    conditionInput.type = 'text';
    conditionInput.placeholder = 'Enter text that triggers alert...';
    conditionInput.style.cssText = 'width: 70%; max-width: 300px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 12px;';
    conditionInput.value = window.triggerLabelAlert[key].condition || '';
    conditionInput.onchange = () => {
        if (!window.triggerLabelAlert[key]) {
            window.triggerLabelAlert[key] = { enabled: true, condition: '', title: '' };
        }
        window.triggerLabelAlert[key].condition = conditionInput.value.trim();
        if (typeof window.requestAutosave === 'function') {
            window.requestAutosave();
        }
    };
    conditionInput.onblur = () => {
        if (!window.triggerLabelAlert[key]) {
            window.triggerLabelAlert[key] = { enabled: true, condition: '', title: '' };
        }
        window.triggerLabelAlert[key].condition = conditionInput.value.trim();
        if (typeof window.requestAutosave === 'function') {
            window.requestAutosave();
        }
    };
    conditionRow.appendChild(conditionInput);
    container.appendChild(conditionRow);
    
    // Title input (same as dropdown version)
    // ... (copy from dropdown implementation)
}
```

STEP 4: Update Export
---------------------
In `download.js`, find where label fields are collected and add:
```javascript
// Check for alert data from window.triggerLabelAlert
const alertKey = `${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`;
if (window.triggerLabelAlert && window.triggerLabelAlert[alertKey]) {
    const storedAlert = window.triggerLabelAlert[alertKey];
    if (storedAlert.enabled && storedAlert.condition && storedAlert.title) {
        labelField.alert = {
            enabled: storedAlert.enabled,
            condition: storedAlert.condition.trim(),
            title: storedAlert.title.trim()
        };
    }
}
```

STEP 5: Update Import
---------------------
In `download.js`, find label field restoration and add alert restoration
(similar to dropdown import, but use "Label" instead of "Dropdown" in IDs).

STEP 6: Update Form Generation
-------------------------------
In `generate.js`, find where label fields are collected and add alert collection
(similar to dropdown collection).

In `createTriggerFieldsContainer`, ensure label fields are enriched with alert
data (already handled by the enrichTriggerFieldWithUnifiedData function).

STEP 7: Add Runtime Alert Check
--------------------------------
In `createTriggerFieldsContainer`, in the label field creation section:
```javascript
// Capture alert data
const alertData = triggerField.alert ? {
    enabled: triggerField.alert.enabled || false,
    condition: (triggerField.alert.condition || '').trim(),
    title: (triggerField.alert.title || '').trim()
} : null;

// Add to input event handler
input.addEventListener('input', function() {
    if (alertData && alertData.enabled && alertData.condition && alertData.title) {
        const inputValue = (this.value || '').trim();
        if (inputValue === alertData.condition) {
            if (typeof showAlert === 'function') {
                showAlert(alertData.title);
        } else {
                alert(alertData.title);
        }
    }
}
});
```

================================================================================
PART 7: COMMON GOTCHAS AND TROUBLESHOOTING
================================================================================

GOTCHA 1: Closure Issues
------------------------
Problem: When iterating through fields with forEach, event handlers may
reference the wrong field data due to closure issues.

Solution: Always capture data in local variables before creating event handlers:
```javascript
const alertData = triggerField.alert ? { ... } : null;
select.addEventListener('change', function() {
    // Use alertData here, not triggerField.alert directly
});
```

GOTCHA 2: Data Not in unifiedFieldsMap
---------------------------------------
Problem: Alert data exists in `window.triggerDropdownAlert` but not in
`unifiedFieldsMap` when form is generated.

Solution: Ensure alert data is collected during form generation (around
lines 1916 and 3280 in generate.js). The enrichTriggerFieldWithUnifiedData
function will then find it at runtime.

GOTCHA 3: UI Not Populated on Import
-------------------------------------
Problem: After importing JSON, alert UI is not shown or values are empty.

Solution: Use nested setTimeout calls to ensure DOM elements exist:
- 200ms: Wait for field to be created
- 400ms: Wait for update function to populate UI
- 300ms: Set values in UI elements

GOTCHA 4: Options Not Available for Condition Dropdown
-------------------------------------------------------
Problem: updateTriggerDropdownAlertUI can't find dropdown options.

Solution: Ensure options are added to the DOM before calling the update
function. The update function reads options from DOM, not from a data structure.

GOTCHA 5: Alert Shows But Uses Default Browser Alert
-----------------------------------------------------
Problem: `showAlert` function not found, falls back to `alert()`.

Solution: Ensure `showAlert` function is defined in generated HTML before
createTriggerFieldsContainer runs. The function should be in the script block
generated by generate.js.

GOTCHA 6: Condition Matching Not Working
-----------------------------------------
Problem: Alert doesn't show even when condition should match.

Solution: Always trim values before comparison:
```javascript
const selectedValue = (this.value || '').trim();
const alertCondition = alertData.condition;
if (selectedValue === alertCondition) { ... }
```

================================================================================
END OF FEATURE #1 DOCUMENTATION
================================================================================

================================================================================
FEATURE #2: ENABLE HARD ALERT FOR TRIGGER DROPDOWN FIELDS
================================================================================

PURPOSE:
--------
Allows form builders to configure "hard alerts" on dropdown fields within
trigger sequences. Hard alerts are similar to regular alerts, but with two
critical differences:
1. They disable the right arrow navigation button when the condition is met
2. They include a subtitle "Please change your answer to proceed" in the alert modal
3. The user cannot proceed to the next question until ALL hard alert conditions are resolved

Example: A dropdown "Are they a public entity?" has options "Yes" and "No".
The form builder can enable a hard alert so that when users select "No", they
see an alert message like "123" with the subtitle, and the right arrow button
becomes disabled (greyed out) until they change their answer.

CONTEXT:
--------
This feature extends the regular alert functionality (Feature #1) with the
ability to block navigation. It's implemented for dropdown fields within trigger
sequences, and is particularly useful for numbered dropdowns where multiple
entries exist (e.g., "How many people are you suing?" creates entries 1, 2, 3...).
The navigation button must remain disabled if ANY entry has an active hard alert.

KEY DIFFERENCES FROM REGULAR ALERTS:
------------------------------------
1. Data storage: Uses `window.triggerDropdownHardAlert` (not `window.triggerDropdownAlert`)
2. Alert display: Calls `showAlert(title, true)` with second parameter `true`
3. Navigation blocking: Requires `checkAllHardAlertsAndUpdateNavigation()` function
4. Button state: `updateButtons()` must check `hardAlertActive` before enabling
5. Multiple entries: Must check ALL entries (1-10) to see if ANY have active hard alerts

================================================================================
PART 1: GUI INTERFACE (FormWiz GUI/gui.js)
================================================================================

1.1 ADDING THE UI CHECKBOX
---------------------------
Location: `addTriggerDropdown()` function (around line 3197, after "Enable Alert" checkbox)

When a dropdown field is added to a trigger sequence, an "Enable Hard Alert" checkbox
is added right after the "Enable Alert" checkbox.

UI Structure:
```html
<div style="margin-bottom: 8px; text-align: center;">
    <label for="enableHardAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}">
        Enable Hard Alert
    </label>
    <div style="display: flex; justify-content: center;">
        <input type="checkbox" 
               id="enableHardAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}"
               onchange="toggleTriggerDropdownHardAlert({questionId}, {fieldCount}, {sequenceCount}, {triggerFieldCount})">
    </div>
    <div id="hardAlertUIDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}" 
         style="margin-top: 8px; display: none;">
        <!-- Hard Alert UI will be populated here -->
    </div>
</div>
```

Key Patterns:
- Checkbox ID pattern: `enableHardAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Container ID pattern: `hardAlertUIDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Container is initially hidden (`display: none`)
- The toggle function is called on checkbox `onchange` event

1.2 TOGGLE FUNCTION
-------------------
Location: `toggleTriggerDropdownHardAlert()` function (around line 4000)

Purpose: Shows/hides the hard alert configuration UI and manages the data structure.

Function Signature:
```javascript
function toggleTriggerDropdownHardAlert(questionId, fieldCount, sequenceCount, triggerFieldCount)
```

Implementation is identical to `toggleTriggerDropdownAlert`, but uses:
- `window.triggerDropdownHardAlert` instead of `window.triggerDropdownAlert`
- `updateTriggerDropdownHardAlertUI` instead of `updateTriggerDropdownAlertUI`
- `enableHardAlertDropdown` and `hardAlertUIDropdown` IDs

1.3 UPDATE UI FUNCTION
----------------------
Location: `updateTriggerDropdownHardAlertUI()` function (around line 4030)

Implementation is identical to `updateTriggerDropdownAlertUI`, but:
- Uses `window.triggerDropdownHardAlert` instead of `window.triggerDropdownAlert`
- Uses `hardAlertUIDropdown` container ID
- Everything else is the same (condition dropdown, title input)

================================================================================
PART 2: EXPORT/IMPORT (FormWiz GUI/download.js)
================================================================================

2.1 EXPORT PROCESS
------------------
Location: Field collection code in `getFormJSON()` function (around line 1916 and 3280)

Export process is identical to regular alerts, but uses `window.triggerDropdownHardAlert`:

```javascript
// Check for hard alert data from window.triggerDropdownHardAlert
const hardAlertKey = `${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`;
if (window.triggerDropdownHardAlert && window.triggerDropdownHardAlert[hardAlertKey]) {
    const storedHardAlert = window.triggerDropdownHardAlert[hardAlertKey];
    if (storedHardAlert.enabled && storedHardAlert.condition && storedHardAlert.title) {
        dropdownField.hardAlert = {
            enabled: storedHardAlert.enabled,
            condition: storedHardAlert.condition.trim(),
            title: storedHardAlert.title.trim()
        };
    }
}
```

JSON Export Format:
```json
{
    "type": "dropdown",
    "fieldName": "Are they a public entity?",
    "options": [
        {"text": "Yes"},
        {"text": "No"}
    ],
    "hardAlert": {
        "enabled": true,
        "condition": "No",
        "title": "123"
    }
}
```

2.2 IMPORT PROCESS
------------------
Location: `loadFormJson()` function, within the dropdown field restoration block

Import process is identical to regular alerts, but uses:
- `window.triggerDropdownHardAlert` instead of `window.triggerDropdownAlert`
- `enableHardAlertDropdown` and `hardAlertUIDropdown` IDs
- `updateTriggerDropdownHardAlertUI` function
- `hardAlert` property instead of `alert` property

================================================================================
PART 3: FORM GENERATION (FormWiz GUI/generate.js)
================================================================================

3.1 COLLECTING HARD ALERT DATA DURING FORM GENERATION
------------------------------------------------------
Location: Two places where dropdown fields are collected from GUI:
1. Around line 1916-1950 (first collection point)
2. Around line 3280-3335 (second collection point)

Implementation is identical to regular alerts, but collects from `window.triggerDropdownHardAlert`:

```javascript
// Check for hard alert data from window.triggerDropdownHardAlert
const hardAlertKey = `${questionId}_${fieldOrder}_${sequenceIndex + 1}_${triggerFieldCount}`;
if (window.triggerDropdownHardAlert && window.triggerDropdownHardAlert[hardAlertKey]) {
    const storedHardAlert = window.triggerDropdownHardAlert[hardAlertKey];
    if (storedHardAlert.enabled && storedHardAlert.condition && storedHardAlert.title) {
        dropdownField.hardAlert = {
            enabled: storedHardAlert.enabled,
            condition: storedHardAlert.condition.trim(),
            title: storedHardAlert.title.trim()
        };
    }
}
```

**For Regular Dropdown Questions (not trigger sequences):**

When collecting hard alert data for regular dropdown questions, store it in `window.hardAlertData`:

```javascript
// Handle Hard Alert - check before generating select
const hardAlertEnabledEl = qBlock.querySelector(`#enableHardAlert${questionId}`);
const hardAlertEnabled = hardAlertEnabledEl && hardAlertEnabledEl.checked;
let hardAlertHandlerCall = '';
if (hardAlertEnabled) {
  const hardAlertTriggerEl = qBlock.querySelector(`#hardAlertTrigger${questionId}`);
  const hardAlertTitleEl = qBlock.querySelector(`#hardAlertTitle${questionId}`);
  const hardAlertTrigger = hardAlertTriggerEl ? hardAlertTriggerEl.value.trim() : "";
  const hardAlertTitle = hardAlertTitleEl ? hardAlertTitleEl.value.trim() : "";
  // Only include handler call if both trigger and title are set
  if (hardAlertTrigger && hardAlertTitle) {
    hardAlertHandlerCall = ` handleHardAlert${questionId}(this.value)`;
    // CRITICAL: Store hard alert data for runtime - MUST include enabled: true
    if (!window.hardAlertData) {
      window.hardAlertData = {};
    }
    window.hardAlertData[questionId] = {
      enabled: true,  // CRITICAL: Must include enabled property
      trigger: hardAlertTrigger,
      title: hardAlertTitle,
      dropdownId: ddNm  // The dropdown element ID
    };
  }
}
```

**CRITICAL: Embedding `window.hardAlertData` in Generated HTML**

The `window.hardAlertData` object MUST be embedded in the generated HTML so it's available
at runtime. Add this line where other global variables are embedded (around line 5372):

```javascript
formHTML += `window.hardAlertData = ${JSON.stringify(window.hardAlertData || {})};\n`;
```

Without this, `checkAllHardAlertsAndUpdateNavigation()` won't be able to find hard alert
data for regular dropdowns, and the navigation button won't be disabled.

3.2 RUNTIME FIELD ENRICHMENT
-----------------------------
Location: `enrichTriggerFieldWithUnifiedData()` function in `createTriggerFieldsContainer()`

The enrichment function must also merge `hardAlert` data:

```javascript
// Merge hardAlert data if present
if (matchingField.hardAlert) {
    triggerField.hardAlert = matchingField.hardAlert;
}
```

3.3 RUNTIME HARD ALERT FUNCTIONALITY
-------------------------------------
Location: `createTriggerFieldsContainer()` function, within dropdown field creation

Step 1: Capture Hard Alert Data
```javascript
// Capture hard alert data in local variable
const hardAlertData = triggerField.hardAlert ? {
    enabled: triggerField.hardAlert.enabled || false,
    condition: (triggerField.hardAlert.condition || '').trim(),
    title: (triggerField.hardAlert.title || '').trim()
} : null;
```

Step 2: Add Hard Alert Check to Change Handler
```javascript
select.addEventListener('change', function() {
    // ... regular alert check ...
    
    // Check for hard alert functionality if enabled
    if (hardAlertData && hardAlertData.enabled && hardAlertData.condition && hardAlertData.title) {
        const selectedValue = (this.value || '').trim();
        const hardAlertCondition = hardAlertData.condition;
        
        if (selectedValue === hardAlertCondition) {
            // Use custom alert modal with hard alert flag (second parameter = true)
            if (typeof showAlert === 'function') {
                showAlert(hardAlertData.title, true); // true = hard alert
            } else {
                alert(hardAlertData.title);
            }
        }
    }
    
    // CRITICAL: Check all hard alerts and update navigation button state
    checkAllHardAlertsAndUpdateNavigation();
    
    // ... rest of change handler ...
});
```

Key Pattern: `checkAllHardAlertsAndUpdateNavigation()` must be called after
checking the individual hard alert, so it can evaluate ALL dropdowns and update
the button state accordingly.

3.4 CUSTOM ALERT MODAL WITH HARD ALERT
---------------------------------------
Location: `showAlert()` function in generated HTML

The `showAlert()` function accepts a second parameter `isHardAlert`:

```javascript
function showAlert(message, isHardAlert) {
    const alertOverlay = document.getElementById('alertOverlay');
    const alertMessage = document.getElementById('alertMessage');
    if (alertOverlay && alertMessage) {
        if (isHardAlert) {
            // For hard alerts, add subtitle
            alertMessage.innerHTML = '<div style="text-align: center;">' +
                '<div style="margin-bottom: 10px;">' + message + '</div>' +
                '<div style="font-size: 0.9em; color: #666; font-style: italic;">Please change your answer to proceed</div>' +
                '</div>';
        } else {
            // Regular alert - just text
            alertMessage.textContent = message;
            }
        alertOverlay.style.display = 'flex';
    }
}
```

3.5 CHECK ALL HARD ALERTS FUNCTION
-----------------------------------
Location: `checkAllHardAlertsAndUpdateNavigation()` function (around line 7578)

Purpose: Checks ALL dropdowns in ALL entries for active hard alerts and updates
the navigation button state accordingly.

CRITICAL IMPLEMENTATION DETAILS:

1. Must check ALL entries (1-10) for numbered dropdowns
2. Must use correct baseNodeId (parent dropdown's fieldName, not questionNameId)
3. Must not use early returns - check all entries even after finding one match
4. Must update button's `hardAlertActive` data attribute
5. **MUST check regular dropdown questions using `window.hardAlertData`**
6. **MUST embed `window.hardAlertData` in generated HTML**
5. **MUST check regular dropdown questions using `window.hardAlertData`**
6. **MUST embed `window.hardAlertData` in generated HTML**

Implementation:

```javascript
function checkAllHardAlertsAndUpdateNavigation() {
    let hasActiveHardAlert = false;

    // Check unifiedFieldsMap for all hard alerts (trigger sequence dropdowns)
    if (window.unifiedFieldsMap) {
        Object.keys(window.unifiedFieldsMap).forEach(questionId => {
            const allFields = window.unifiedFieldsMap[questionId];
            if (!Array.isArray(allFields)) return;

            // Check all dropdown fields in trigger sequences
            allFields.forEach(field => {
                if (field.type === 'dropdown' && field.triggerSequences && Array.isArray(field.triggerSequences)) {
                    field.triggerSequences.forEach((sequence, seqIndex) => {
                        if (sequence.fields && Array.isArray(sequence.fields)) {
                            sequence.fields.forEach(triggerField => {
                                // Check for hard alert
                                if (triggerField.type === 'dropdown' && triggerField.hardAlert && triggerField.hardAlert.enabled) {
                                    const hardAlertCondition = (triggerField.hardAlert.condition || '').trim();
                                    
                                    if (hardAlertCondition) {
                                        // CRITICAL: Use parent dropdown's fieldName (sanitized) as baseNodeId
                                        // For numbered dropdowns, this matches how createTriggerFieldsContainer creates IDs
                                        let baseNodeId = '';
                                        if (field.fieldName) {
                                            baseNodeId = (field.fieldName || '').toLowerCase()
                                                .replace(/[?]/g, '')
                                                .replace(/[^a-z0-9_]+/g, '_')
                                                .replace(/^_+|_+$/g, '');
                                        } else if (field.nodeId) {
                                            baseNodeId = field.nodeId;
                                        } else {
                                            baseNodeId = (window.questionNameIds && window.questionNameIds[questionId]) || ('answer' + questionId);
                                        }
                                        
                                        // Sanitize trigger field name
                                        const sanitizedFieldName = (triggerField.fieldName || '').toLowerCase()
                                            .replace(/[?]/g, '')
                                            .replace(/[^a-z0-9_]+/g, '_')
                                            .replace(/^_+|_+$/g, '');
                                        
                                        // Check ALL entries (1-10) - don't return early!
                                        for (let entryNum = 1; entryNum <= 10; entryNum++) {
                                            const dropdownId = baseNodeId + '_' + sanitizedFieldName + '_' + entryNum;
                                            const dropdownEl = document.getElementById(dropdownId);
                                            
                                            if (dropdownEl) {
                                                const selectedValue = (dropdownEl.value || '').trim();
                                                if (selectedValue === hardAlertCondition) {
                                                    hasActiveHardAlert = true;
                                                    // Don't return - continue checking all entries
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    });
                }
            });
        });
    }

    // CRITICAL: Check regular dropdown questions for hard alerts
    // This is required for hard alerts on regular dropdown questions (not trigger sequences)
    if (window.hardAlertData) {
        Object.keys(window.hardAlertData).forEach(questionId => {
            const hardAlertInfo = window.hardAlertData[questionId];
            // CRITICAL: Must check for enabled property - it must be included when storing data
            if (hardAlertInfo && hardAlertInfo.enabled && hardAlertInfo.trigger && hardAlertInfo.dropdownId) {
                const dropdownEl = document.getElementById(hardAlertInfo.dropdownId);
                if (dropdownEl) {
                    const selectedValue = (dropdownEl.value || '').trim();
                    if (selectedValue === hardAlertInfo.trigger.trim()) {
                        hasActiveHardAlert = true;
                    }
                }
            }
        });
    }

    // CRITICAL: Check regular dropdown questions for hard alerts
    // This is required for hard alerts on regular dropdown questions (not trigger sequences)
    if (window.hardAlertData) {
        Object.keys(window.hardAlertData).forEach(questionId => {
            const hardAlertInfo = window.hardAlertData[questionId];
            // CRITICAL: Must check for enabled property - it must be included when storing data
            if (hardAlertInfo && hardAlertInfo.enabled && hardAlertInfo.trigger && hardAlertInfo.dropdownId) {
                const dropdownEl = document.getElementById(hardAlertInfo.dropdownId);
                if (dropdownEl) {
                    const selectedValue = (dropdownEl.value || '').trim();
                    if (selectedValue === hardAlertInfo.trigger.trim()) {
                        hasActiveHardAlert = true;
                    }
                }
            }
        });
    }

    // Update navigation button state
    const activeSection = document.querySelector('.section.active');
    if (activeSection) {
        const nextBtn = activeSection.querySelector('.question-next');
        if (nextBtn) {
            const previousState = nextBtn.dataset.hardAlertActive;
            nextBtn.dataset.hardAlertActive = hasActiveHardAlert ? 'true' : 'false';

            if (hasActiveHardAlert) {
                nextBtn.setAttribute('disabled', 'disabled');
                nextBtn.style.opacity = '0.5';
                nextBtn.style.cursor = 'not-allowed';
            } else {
                // Remove hard alert styling if previously disabled
                if (previousState === 'true') {
                    nextBtn.style.opacity = '';
                    nextBtn.style.cursor = '';
                    // Trigger refreshNav to re-evaluate button state normally
                    const sectionId = activeSection.id;
                    if (window.questionNavControllers && typeof window.questionNavControllers[sectionId] === 'function') {
                        window.questionNavControllers[sectionId]();
                    }
                }
            }
        }
    }
}
```

KEY PATTERNS:
- Use `field.fieldName` (sanitized) for baseNodeId, NOT `questionNameIds[questionId]`
- Check ALL entries (1-10) - never return early from the loop
- Set `hardAlertActive` data attribute on button
- Call `refreshNav()` if hard alert was just cleared (to re-evaluate normally)

3.6 UPDATE BUTTONS FUNCTION MODIFICATION
-----------------------------------------
Location: `updateButtons()` function in navigation code (around line 4485)

The `updateButtons()` function must check for hard alerts BEFORE enabling the button:

```javascript
// CRITICAL FIX: Check for hard alerts before enabling the button
// Hard alerts should always prevent navigation, regardless of canAdvance state
const hasHardAlert = nextBtn.dataset.hardAlertActive === 'true';

// Don't enable if there's an active hard alert
if (canAdvance && !hasHardAlert) {
    nextBtn.removeAttribute('disabled');
    // Make sure styling is cleared if not disabled by hard alert
    if (nextBtn.dataset.hardAlertActive !== 'true') {
        nextBtn.style.opacity = '';
        nextBtn.style.cursor = '';
    }
} else {
    if (hasHardAlert) {
        // Keep disabled due to hard alert
    }
    nextBtn.setAttribute('disabled', 'disabled');
}
```

This ensures that even if `refreshNav()` is called and `updateButtons()` runs,
the button won't be enabled if a hard alert is active.

3.7 CALLING CHECK FUNCTION ON DROPDOWN CHANGES
-----------------------------------------------
Location: Dropdown change event handler in `createTriggerFieldsContainer()`

Must call `checkAllHardAlertsAndUpdateNavigation()` whenever a dropdown value changes:

```javascript
select.addEventListener('change', function() {
    // ... hard alert check and showAlert() call ...
    
    // CRITICAL: Check all hard alerts and update navigation button
    checkAllHardAlertsAndUpdateNavigation();
    
    // ... rest of change handler ...
});
```

Also call on initial page load:

```javascript
// In DOMContentLoaded or window.onload
setTimeout(() => {
    if (typeof checkAllHardAlertsAndUpdateNavigation === 'function') {
        checkAllHardAlertsAndUpdateNavigation();
    }
}, 500);
```

================================================================================
PART 4: DATA FLOW SUMMARY
================================================================================

1. USER CONFIGURATION (GUI):
   - User checks "Enable Hard Alert" checkbox
   - Toggle function stores data in `window.triggerDropdownHardAlert[key]`
   - Update function populates UI and saves condition/title

2. AUTOSAVE:
   - Data is saved to Firebase/localStorage automatically
   - Uses `window.requestAutosave()` function

3. EXPORT (Generate JSON):
   - `download.js` reads from `window.triggerDropdownHardAlert`
   - Adds `hardAlert: {enabled, condition, title}` to dropdownField
   - Exported in JSON format

4. IMPORT (Load JSON):
   - Reads `hardAlert` property from imported JSON
   - Restores to `window.triggerDropdownHardAlert`
   - Updates UI checkboxes and inputs

5. FORM GENERATION:
   - `generate.js` collects hard alert data from `window.triggerDropdownHardAlert`
   - Includes in `unifiedFieldsMap` which is embedded in HTML

6. RUNTIME (Generated Form):
   - `createTriggerFieldsContainer` enriches fields from `unifiedFieldsMap`
   - Hard alert data is merged into triggerField object
   - Change event handler checks condition and calls `showAlert(title, true)`
   - `checkAllHardAlertsAndUpdateNavigation()` is called to check ALL entries
   - Navigation button is disabled if ANY entry has active hard alert
   - `updateButtons()` respects `hardAlertActive` state

================================================================================
PART 5: KEY PATTERNS AND CONVENTIONS
================================================================================

5.1 NAMING CONVENTIONS
----------------------
- Checkbox ID: `enableHardAlertDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Container ID: `hardAlertUIDropdown{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}`
- Data key: `"{questionId}_{fieldCount}_{sequenceCount}_{triggerFieldCount}"` (same as regular alerts)
- Window object: `window.triggerDropdownHardAlert`

5.2 DATA STRUCTURE
------------------
```javascript
window.triggerDropdownHardAlert = {
    "1_5_1_4": {  // Key: questionId_fieldCount_sequenceCount_triggerFieldCount
        enabled: true,
        condition: "No",  // The option value that triggers the hard alert
        title: "123"  // The alert message
    }
}
```

5.3 CRITICAL IMPLEMENTATION DETAILS
------------------------------------

1. BASE NODE ID FOR NUMBERED DROPDOWNS:
   - MUST use parent dropdown's `fieldName` (sanitized), NOT `questionNameIds[questionId]`
   - Example: `"are_they_a_business_or_public_entity"` not `"how_many_people_are_you_suing"`
   - This matches how `createTriggerFieldsContainer` constructs dropdown IDs

2. CHECK ALL ENTRIES:
   - Must check entries 1-10 for numbered dropdowns
   - Never return early from the check loop
   - Button must stay disabled if ANY entry has active hard alert

3. BUTTON STATE MANAGEMENT:
   - `hardAlertActive` data attribute must be set on button
   - `updateButtons()` must check this before enabling
   - `checkAllHardAlertsAndUpdateNavigation()` must be called on every dropdown change

4. ALERT MODAL:
   - Call `showAlert(title, true)` with `true` as second parameter
   - Modal will automatically add subtitle "Please change your answer to proceed"

================================================================================
PART 6: COMMON GOTCHAS AND TROUBLESHOOTING
================================================================================

GOTCHA 1: Wrong baseNodeId Used
--------------------------------
Problem: Navigation button enables even when hard alert is active.

Solution: Ensure `checkAllHardAlertsAndUpdateNavigation()` uses `field.fieldName`
(sanitized) for baseNodeId, NOT `questionNameIds[questionId]`. The dropdown IDs
are created as `{parentDropdownFieldName}_{triggerFieldName}_{entryNumber}`, not
`{questionNodeId}_{triggerFieldName}_{entryNumber}`.

GOTCHA 2: Button Enables After Changing One Entry
--------------------------------------------------
Problem: With multiple entries, changing one entry to resolve its hard alert
enables the button even if other entries still have active hard alerts.

Solution: Ensure `checkAllHardAlertsAndUpdateNavigation()` checks ALL entries
(1-10) and never returns early from the loop. Set `hasActiveHardAlert = true`
when ANY entry matches, but continue checking all entries.

GOTCHA 3: refreshNav Enables Button
------------------------------------
Problem: After clearing a hard alert, `refreshNav()` is called which enables
the button even though hard alerts might still be active.

Solution: Ensure `updateButtons()` checks `nextBtn.dataset.hardAlertActive === 'true'`
BEFORE enabling the button. The check must happen AFTER `checkAllHardAlertsAndUpdateNavigation()`
runs and updates the data attribute.

GOTCHA 4: Hard Alert Check Not Called on Change
------------------------------------------------
Problem: Navigation button doesn't update when dropdown value changes.

Solution: Ensure `checkAllHardAlertsAndUpdateNavigation()` is called in the
dropdown's `change` event handler, AFTER checking for the individual hard alert.

GOTCHA 5: Hard Alert Not Shown
-------------------------------
Problem: Alert modal shows but doesn't have the subtitle.

Solution: Ensure `showAlert(title, true)` is called with `true` as the second
parameter. Check that `showAlert()` function handles the `isHardAlert` parameter.

GOTCHA 6: Navigation Button Not Disabled for Regular Dropdowns
----------------------------------------------------------------
Problem: Hard alert shows correctly, but the right arrow button is not greyed out
and disabled for regular dropdown questions.

Solution: This is a CRITICAL issue that requires two fixes:

1. **Include `enabled: true` when storing data**: When storing hard alert data in
   `window.hardAlertData`, you MUST include the `enabled: true` property:
   ```javascript
   window.hardAlertData[questionId] = {
       enabled: true,  // CRITICAL: Must be included
       trigger: hardAlertTrigger,
       title: hardAlertTitle,
       dropdownId: ddNm
   };
   ```

2. **Embed `window.hardAlertData` in generated HTML**: The `window.hardAlertData`
   object must be embedded in the generated HTML so it's available at runtime.
   Add this line where other global variables are embedded:
   ```javascript
   formHTML += `window.hardAlertData = ${JSON.stringify(window.hardAlertData || {})};\n`;
   ```

Without both of these, `checkAllHardAlertsAndUpdateNavigation()` won't be able to
find the hard alert data, and the button won't be disabled.

================================================================================
END OF FEATURE #2 DOCUMENTATION
================================================================================

================================================================================
FEATURE #3: ENABLE STATUS FOR DROPDOWN QUESTIONS
================================================================================

PURPOSE:
--------
Allows form builders to configure status tracking for dropdown questions. When a
user selects a specific option in the generated form, a status is added to
`window.formStatuses`. If the user changes their selection, the status is removed.
Statuses can be used by other features (like alert logic status requirements) to
check if certain conditions are met.

Example: A dropdown "Hungry?" has options "Yes" and "No". The form builder can
enable status so that when users select "Yes", a status "needs_food" is added.
This status can then be referenced in alert logic conditions to only show alerts
when the status is active.

CONTEXT:
--------
This feature is implemented for dropdown questions (not trigger sequence dropdowns).
It's a simple status tracking system that maintains a global `window.formStatuses`
object where keys are status titles and values are `true` (active) or the status
is removed (inactive).

KEY CONCEPTS:
------------
1. Status Trigger: The dropdown option value that activates the status
2. Status Title: The unique identifier for the status (e.g., "needs_food")
3. Status Lifecycle: Status is added when trigger option is selected, removed when changed
4. Global State: All statuses are stored in `window.formStatuses` object
5. Console Logging: Status changes are logged to console for debugging

================================================================================
PART 1: GUI INTERFACE (FormWiz GUI/gui.js)
================================================================================

1.1 ADDING THE UI CHECKBOX
---------------------------
Location: `addQuestion()` function (around line 805)

When a question is added, an "Enable Status" checkbox is added after the
"Enable Hidden Logic" section.

UI Structure:
```html
<label>Enable Status: </label>
<input type="checkbox" id="enableStatus${currentQuestionId}" onchange="toggleStatus(${currentQuestionId})">
<div id="statusBlock${currentQuestionId}" style="display: none; margin-top: 10px;">
    <label>Status Trigger:</label>
    <select id="statusTrigger${currentQuestionId}">
        <option value="">Select an option...</option>
    </select><br><br>
    <label>Status Title:</label>
    <input type="text" id="statusTitle${currentQuestionId}" placeholder="Enter status title (e.g., needs_food)">
</div><br>
```

Key Patterns:
- Checkbox ID pattern: `enableStatus{questionId}`
- Container ID pattern: `statusBlock{questionId}`
- Trigger dropdown ID: `statusTrigger{questionId}`
- Title input ID: `statusTitle{questionId}`
- Container is initially hidden (`display: none`)

1.2 TOGGLE FUNCTION
-------------------
Location: `toggleStatus()` function (around line 4826)

Purpose: Shows/hides the status configuration UI and manages the data structure.

Function Signature:
```javascript
function toggleStatus(questionId)
```

Implementation Steps:

Step 1: Get DOM Elements
```javascript
const statusEnabled = document.getElementById(`enableStatus${questionId}`).checked;
const statusBlock = document.getElementById(`statusBlock${questionId}`);
if (!statusBlock) return;
```

Step 2: Show/Hide UI
```javascript
statusBlock.style.display = statusEnabled ? 'block' : 'none';
```

Step 3: Initialize Data Structure
```javascript
if (!window.questionStatus) {
    window.questionStatus = {};
}
if (!window.questionStatus[questionId]) {
    window.questionStatus[questionId] = { enabled: false, trigger: '', title: '' };
}
window.questionStatus[questionId].enabled = statusEnabled;
```

Step 4: Populate Trigger Options or Clear Data
```javascript
if (statusEnabled) {
    updateStatusTriggerOptions(questionId);
} else {
    // Clear status data when disabled
    window.questionStatus[questionId].trigger = '';
    window.questionStatus[questionId].title = '';
}
```

Step 5: Trigger Autosave
```javascript
if (typeof window.requestAutosave === 'function') {
    window.requestAutosave();
}
```

Data Storage:
- Stored in: `window.questionStatus[questionId]`
- Structure: `{ enabled: boolean, trigger: string, title: string }`

1.3 UPDATE TRIGGER OPTIONS FUNCTION
------------------------------------
Location: `updateStatusTriggerOptions()` function (around line 4858)

Purpose: Populates the "Status Trigger" dropdown with options from the current
dropdown question. This ensures the trigger dropdown always reflects the current
options of the parent dropdown.

Function Signature:
```javascript
function updateStatusTriggerOptions(questionId)
```

Implementation Steps:

Step 1: Get Trigger Select and Save Current Value
```javascript
const triggerSelect = document.getElementById(`statusTrigger${questionId}`);
if (!triggerSelect) return;

// Save the currently selected value
const currentValue = triggerSelect.value;
```

Step 2: Clear and Repopulate Options
```javascript
// Clear existing options (except the placeholder)
triggerSelect.innerHTML = '<option value="">Select an option...</option>';

// Get all dropdown options for this question
const dropdownOptionsDiv = document.getElementById(`dropdownOptions${questionId}`);
if (dropdownOptionsDiv) {
    const optionInputs = dropdownOptionsDiv.querySelectorAll('input[type="text"]');
    optionInputs.forEach((input) => {
        const optionText = input.value.trim();
        if (optionText) {
            const option = document.createElement('option');
            option.value = optionText;
            option.textContent = optionText;
            if (optionText === currentValue) {
                option.selected = true;
            }
            triggerSelect.appendChild(option);
        }
    });
}
```

Step 3: Add Change Handler
```javascript
triggerSelect.onchange = () => {
    if (!window.questionStatus) {
        window.questionStatus = {};
    }
    if (!window.questionStatus[questionId]) {
        window.questionStatus[questionId] = { enabled: false, trigger: '', title: '' };
    }
    window.questionStatus[questionId].trigger = triggerSelect.value;
    if (typeof window.requestAutosave === 'function') {
        window.requestAutosave();
    }
};
```

Step 4: Add Change Handler for Title Input
```javascript
const titleInput = document.getElementById(`statusTitle${questionId}`);
if (titleInput) {
    titleInput.onchange = () => {
        if (!window.questionStatus) {
            window.questionStatus = {};
        }
        if (!window.questionStatus[questionId]) {
            window.questionStatus[questionId] = { enabled: false, trigger: '', title: '' };
        }
        window.questionStatus[questionId].title = titleInput.value.trim();
        if (typeof window.requestAutosave === 'function') {
            window.requestAutosave();
        }
    };
    titleInput.onblur = () => {
        // Same as onchange - ensures data is saved
        if (!window.questionStatus) {
            window.questionStatus = {};
        }
        if (!window.questionStatus[questionId]) {
            window.questionStatus[questionId] = { enabled: false, trigger: '', title: '' };
        }
        window.questionStatus[questionId].title = titleInput.value.trim();
        if (typeof window.requestAutosave === 'function') {
            window.requestAutosave();
        }
    };
}
```

Key Pattern: The trigger dropdown is populated from the DOM (dropdown options
container), not from a data structure. This means options must exist in the DOM
before calling this function.

1.4 SYNCING WITH DROPDOWN OPTIONS
----------------------------------
Location: `addDropdownOption()` and `removeDropdownOption()` functions

When dropdown options are added or removed, the status trigger dropdown must be
updated to reflect the changes.

Implementation:
```javascript
// In addDropdownOption() function
function addDropdownOption(questionId, fieldCount) {
    // ... add option to dropdown ...
    
    // Update status trigger options if status is enabled
    const statusCheckbox = document.getElementById(`enableStatus${questionId}`);
    if (statusCheckbox && statusCheckbox.checked) {
        updateStatusTriggerOptions(questionId);
    }
}

// In removeDropdownOption() function
function removeDropdownOption(questionId, fieldCount, optionCount) {
    // ... remove option from dropdown ...
    
    // Update status trigger options if status is enabled
    const statusCheckbox = document.getElementById(`enableStatus${questionId}`);
    if (statusCheckbox && statusCheckbox.checked) {
        updateStatusTriggerOptions(questionId);
    }
}
```

This ensures the status trigger dropdown always matches the current dropdown options.

================================================================================
PART 2: EXPORT/IMPORT (FormWiz GUI/download.js)
================================================================================

2.1 EXPORT PROCESS
------------------
Location: Question data collection in `getFormJSON()` function (around line 3095)

When collecting question data for JSON export, status data must be read from
`window.questionStatus` and added to the question object.

Implementation:

```javascript
// Collect Status data
const statusEnabled = questionBlock.querySelector(`#enableStatus${questionId}`)?.checked || false;
const statusTrigger = questionBlock.querySelector(`#statusTrigger${questionId}`)?.value || "";
const statusTitle = questionBlock.querySelector(`#statusTitle${questionId}`)?.value || "";

// Also check window.questionStatus as fallback
let storedStatusData = null;
if (window.questionStatus && window.questionStatus[questionId]) {
    storedStatusData = window.questionStatus[questionId];
    }

// Use stored data if available, otherwise use UI values
const finalStatusEnabled = storedStatusData ? storedStatusData.enabled : statusEnabled;
const finalStatusTrigger = storedStatusData ? storedStatusData.trigger : statusTrigger;
const finalStatusTitle = storedStatusData ? storedStatusData.title : statusTitle;

// Add to question object
questionData.status = {
    enabled: finalStatusEnabled,
    trigger: finalStatusTrigger,
    title: finalStatusTitle
};
```

JSON Export Format:
```json
{
    "questionId": 1,
    "text": "Hungry?",
    "type": "dropdown",
    "status": {
        "enabled": true,
        "trigger": "Yes",
        "title": "needs_food"
    },
    "options": ["Yes", "No"]
}
```

2.2 IMPORT PROCESS
------------------
Location: `loadFormJson()` function, within question restoration block (around line 514)

When importing a JSON file, status data must be restored to `window.questionStatus`
and the UI must be updated.

Implementation:

```javascript
// Restore Status
if (question.status && question.status.enabled) {
    const statusCheckbox = questionBlock.querySelector(`#enableStatus${question.questionId}`);
    const statusTriggerSelect = questionBlock.querySelector(`#statusTrigger${question.questionId}`);
    const statusTitleInput = questionBlock.querySelector(`#statusTitle${question.questionId}`);
    
    if (statusCheckbox) {
        statusCheckbox.checked = true;
        toggleStatus(question.questionId); // This populates the trigger dropdown with options from DOM
        
        // Set the trigger value after the dropdown is populated
setTimeout(() => {
            if (statusTriggerSelect && question.status.trigger) {
                statusTriggerSelect.value = question.status.trigger;
                statusTriggerSelect.dispatchEvent(new Event('change'));
            }
            if (statusTitleInput && question.status.title) {
                statusTitleInput.value = question.status.title;
                statusTitleInput.dispatchEvent(new Event('blur'));
            }
        }, 100);
    }
    
    // Also restore to window.questionStatus
    if (!window.questionStatus) {
        window.questionStatus = {};
    }
    window.questionStatus[question.questionId] = {
        enabled: true,
        trigger: question.status.trigger || '',
        title: question.status.title || ''
    };
}
```

Key Patterns:
- Must call `toggleStatus()` to populate the trigger dropdown
- Use `setTimeout` to ensure dropdown is populated before setting value
- Dispatch events to trigger handlers
- Restore to both UI and `window.questionStatus`

================================================================================
PART 3: FORM GENERATION (FormWiz GUI/generate.js)
================================================================================

3.1 COLLECTING STATUS DATA DURING FORM GENERATION
-------------------------------------------------
Location: Question processing loop in `getFormHTML()` function (around line 1200-1300)

When building the form HTML, status data must be collected and embedded in the
generated HTML for runtime use.

Implementation:

```javascript
// Check if Status is enabled
const statusCheckbox = qBlock.querySelector("#enableStatus" + questionId);
const statusEnabled = statusCheckbox && statusCheckbox.checked;

let statusTrigger = '';
let statusTitle = '';

if (statusEnabled) {
    // Get from window.questionStatus first (preferred)
    if (window.questionStatus && window.questionStatus[questionId]) {
        statusTrigger = window.questionStatus[questionId].trigger || '';
        statusTitle = window.questionStatus[questionId].title || '';
    } else {
        // Fallback to UI elements
        const statusTriggerEl = qBlock.querySelector("#statusTrigger" + questionId);
        const statusTitleEl = qBlock.querySelector("#statusTitle" + questionId);
        statusTrigger = statusTriggerEl ? statusTriggerEl.value.trim() : '';
        statusTitle = statusTitleEl ? statusTitleEl.value.trim() : '';
    }
}

// Store for runtime
if (!window.statusData) {
    window.statusData = {};
}
window.statusData[questionId] = {
    enabled: statusEnabled,
    trigger: statusTrigger,
    title: statusTitle
};
```

3.2 ADDING STATUS HANDLER TO DROPDOWN
--------------------------------------
Location: Dropdown generation in `getFormHTML()` function (around line 1246)

When a dropdown is generated, if status is enabled, a status handler function
call must be added to the dropdown's `onchange` attribute.

Implementation:

```javascript
// Build onchange attribute
let onchangeAttr = 'dropdownMirror(this, \'' + questionNameId + '\'); updateHiddenLogic(\'' + questionNameId + '\', this.value); updateLinkedFields(); clearInactiveLinkedFields();';

// Add status handler if enabled
if (statusEnabled && statusTrigger && statusTitle) {
    statusHandlerCall = ` handleStatus${questionId}(this.value)`;
    onchangeAttr += statusHandlerCall;
}

// Add to select element
select.setAttribute('onchange', onchangeAttr);
```

3.3 GENERATING STATUS HANDLER FUNCTION
---------------------------------------
Location: Status handler generation in `getFormHTML()` function (around line 1540)

A handler function is generated for each question with status enabled. This function
manages the `window.formStatuses` object.

Implementation:

```javascript
if (statusEnabled && statusTrigger && statusTitle) {
    formHTML += `
        function handleStatus${questionId}(value) {
            // Initialize status object if it doesn't exist
            if (!window.formStatuses) {
                window.formStatuses = {};
            }
            
            const selectedValue = (value || '').trim();
            const statusTrigger = '${statusTrigger}';
            const statusTitle = '${statusTitle}';
            
            // Check if selected value matches the trigger
            if (selectedValue === statusTrigger) {
                // Add status if it doesn't exist
                if (!window.formStatuses[statusTitle]) {
                    window.formStatuses[statusTitle] = true;
                    console.log('[STATUS] Status added:', statusTitle);
                    console.log('[STATUS] Current statuses:', window.formStatuses);
                } else {
                    console.log('[STATUS] Status already exists:', statusTitle);
                }
            } else {
                // Remove status if it exists
                if (window.formStatuses[statusTitle]) {
                    delete window.formStatuses[statusTitle];
                    console.log('[STATUS] Status removed:', statusTitle);
                    console.log('[STATUS] Current statuses:', window.formStatuses);
                }
            }
        }
    `;
}
```

Key Patterns:
- Function name: `handleStatus{questionId}`
- Compares selected value to trigger (exact match, trimmed)
- Adds status to `window.formStatuses[statusTitle] = true` when trigger matches
- Removes status (deletes key) when trigger doesn't match
- Console logs for debugging

================================================================================
PART 4: RUNTIME BEHAVIOR (Generated Form)
================================================================================

4.1 STATUS ACTIVATION
---------------------
When a user selects the trigger option in the dropdown:
1. The dropdown's `onchange` event fires
2. `handleStatus{questionId}(this.value)` is called
3. Function compares value to trigger
4. If match: `window.formStatuses[statusTitle] = true`
5. Console log confirms status addition

4.2 STATUS DEACTIVATION
-----------------------
When a user changes the dropdown to a different option:
1. The dropdown's `onchange` event fires
2. `handleStatus{questionId}(this.value)` is called
3. Function compares value to trigger
4. If no match: `delete window.formStatuses[statusTitle]`
5. Console log confirms status removal

4.3 STATUS USAGE IN OTHER FEATURES
-----------------------------------
Statuses can be checked by other features:

Example - Alert Logic Status Requirements:
```javascript
// In checkAlertLogic() function
if (condition.statusRequirements && condition.statusRequirements.length > 0) {
    let allStatusRequirementsMet = true;
    for (const statusReq of condition.statusRequirements) {
        if (!window.formStatuses || !window.formStatuses[statusReq]) {
            allStatusRequirementsMet = false;
            break;
        }
    }
    if (!allStatusRequirementsMet) {
        continue; // Skip this condition
    }
}
```

4.4 STATUS OBJECT STRUCTURE
----------------------------
```javascript
window.formStatuses = {
    "needs_food": true,
    "needs_water": true,
    "needs_shelter": true
}
```

- Keys are status titles (e.g., "needs_food")
- Values are `true` (status is active)
- If a key doesn't exist, the status is inactive
- Statuses are global across the entire form

================================================================================
PART 5: DATA FLOW SUMMARY
================================================================================

1. USER CONFIGURATION (GUI):
   - User checks "Enable Status" checkbox
   - Toggle function stores data in `window.questionStatus[questionId]`
   - Update function populates trigger dropdown with current options
   - User selects trigger option and enters status title
   - Data is saved to `window.questionStatus`

2. AUTOSAVE:
   - Data is saved to Firebase/localStorage automatically
   - Uses `window.requestAutosave()` function

3. EXPORT (Generate JSON):
   - `download.js` reads from `window.questionStatus` (with UI fallback)
   - Adds `status: {enabled, trigger, title}` to question object
   - Exported in JSON format

4. IMPORT (Load JSON):
   - Reads `status` property from imported JSON
   - Restores to `window.questionStatus`
   - Updates UI checkboxes and inputs
   - Calls `toggleStatus()` to populate trigger dropdown
   - Uses setTimeout to set values after dropdown is populated

5. FORM GENERATION:
   - `generate.js` collects status data from `window.questionStatus` (with UI fallback)
   - Stores in `window.statusData` for runtime
   - Generates `handleStatus{questionId}()` function
   - Adds function call to dropdown's `onchange` attribute

6. RUNTIME (Generated Form):
   - User selects dropdown option
   - `handleStatus{questionId}()` is called
   - Function checks if value matches trigger
   - Adds/removes status from `window.formStatuses`
   - Other features can check `window.formStatuses` for status requirements

================================================================================
PART 6: KEY PATTERNS AND CONVENTIONS
================================================================================

6.1 NAMING CONVENTIONS
----------------------
- Checkbox ID: `enableStatus{questionId}`
- Container ID: `statusBlock{questionId}`
- Trigger dropdown ID: `statusTrigger{questionId}`
- Title input ID: `statusTitle{questionId}`
- Handler function: `handleStatus{questionId}(value)`
- Window object: `window.questionStatus` (GUI) and `window.formStatuses` (runtime)

6.2 DATA STRUCTURE
------------------
GUI Storage:
```javascript
window.questionStatus = {
    "1": {  // Key: questionId
        enabled: true,
        trigger: "Yes",  // The option value that activates the status
        title: "needs_food"  // The status identifier
    }
}
```

Runtime Storage:
```javascript
window.formStatuses = {
    "needs_food": true,  // Key: status title, Value: true (active)
    "needs_water": true
}
```

6.3 TOGGLE FUNCTION PATTERN
---------------------------
1. Get checkbox and container elements
2. Show/hide container based on checkbox state
3. Initialize `window.questionStatus` if needed
4. Update enabled state in data structure
5. Call `updateStatusTriggerOptions()` if enabled, clear data if disabled
6. Trigger autosave

6.4 UPDATE FUNCTION PATTERN
---------------------------
1. Get trigger select element
2. Save current value
3. Clear and repopulate from DOM (dropdown options container)
4. Restore saved value if it still exists
5. Add change handlers to save data and trigger autosave

6.5 EXPORT PATTERN
------------------
1. Check `window.questionStatus` for stored data (preferred)
2. Check UI elements as fallback
3. Add `status: {enabled, trigger, title}` to question object
4. Include in JSON export

6.6 IMPORT PATTERN
------------------
1. Check for `status` property in imported JSON
2. Restore to `window.questionStatus`
3. Check checkbox and call `toggleStatus()` to populate UI
4. Use setTimeout to set values after dropdown is populated
5. Dispatch events to trigger handlers

6.7 RUNTIME GENERATION PATTERN
-------------------------------
1. Collect status data during form generation
2. Store in `window.statusData` for reference
3. Generate `handleStatus{questionId}()` function
4. Add function call to dropdown's `onchange` attribute
5. Function manages `window.formStatuses` at runtime

================================================================================
PART 7: COMMON GOTCHAS AND TROUBLESHOOTING
================================================================================

GOTCHA 1: Trigger Dropdown Not Populated
-----------------------------------------
Problem: Status trigger dropdown is empty when enabling status.

Solution: Ensure `updateStatusTriggerOptions()` is called after enabling status.
The function reads options from the DOM (`#dropdownOptions{questionId}`), so options
must exist in the DOM first. Also ensure `addDropdownOption()` and `removeDropdownOption()`
call `updateStatusTriggerOptions()` to keep it in sync.

GOTCHA 2: Status Not Added at Runtime
--------------------------------------
Problem: Status handler function is not called when dropdown value changes.

Solution: Ensure the status handler call is added to the dropdown's `onchange`
attribute during form generation. Check that `statusHandlerCall` is appended to
the `onchangeAttr` string before setting it on the select element.

GOTCHA 3: Status Not Removed When Changed
------------------------------------------
Problem: Status remains active even after changing dropdown to a different option.

Solution: Ensure the status handler function checks for both match (add) and
non-match (remove) cases. The function should delete the status when the value
doesn't match the trigger.

GOTCHA 4: Status Requirements Not Working
------------------------------------------
Problem: Alert logic status requirements don't work even though status is active.

Solution: Ensure status requirements check `window.formStatuses[statusTitle]`
exists (not just truthy). The check should be:
```javascript
if (!window.formStatuses || !window.formStatuses[statusReq]) {
    // Status requirement not met
}
```

GOTCHA 5: Import Not Restoring Status
--------------------------------------
Problem: After importing JSON, status UI is not shown or values are empty.

Solution: Ensure `toggleStatus()` is called to populate the trigger dropdown
before setting values. Use setTimeout to ensure dropdown is populated:
```javascript
setTimeout(() => {
    if (statusTriggerSelect && question.status.trigger) {
        statusTriggerSelect.value = question.status.trigger;
    }
}, 100);
```

GOTCHA 6: Multiple Statuses with Same Title
--------------------------------------------
Problem: Multiple questions use the same status title, causing conflicts.

Solution: Status titles should be unique across the form. If two questions use
the same title, they will share the same status. Consider using descriptive,
unique titles like "question1_needs_food" vs "question2_needs_food" if needed.

================================================================================
PART 8: REPLICATING FOR OTHER QUESTION TYPES
================================================================================

To add status functionality to checkbox questions:

STEP 1: Add UI Checkbox
-----------------------
In `addQuestion()`, add status checkbox (same as dropdown).

STEP 2: Create Toggle Function
-------------------------------
Same as dropdown, but may need different trigger options (e.g., "checked" vs "unchecked").

STEP 3: Update Form Generation
-------------------------------
Generate handler function that checks checkbox state:
```javascript
function handleStatus${questionId}(checked) {
    if (!window.formStatuses) {
        window.formStatuses = {};
    }
    
    const statusTrigger = '${statusTrigger}'; // e.g., "checked" or "unchecked"
    const statusTitle = '${statusTitle}';
    
    if ((checked && statusTrigger === 'checked') || (!checked && statusTrigger === 'unchecked')) {
        window.formStatuses[statusTitle] = true;
    } else {
        delete window.formStatuses[statusTitle];
    }
}
```

STEP 4: Add Handler to Checkbox
--------------------------------
```javascript
checkbox.addEventListener('change', function() {
    handleStatus${questionId}(this.checked);
});
```

================================================================================
END OF FEATURE #3 DOCUMENTATION
================================================================================
